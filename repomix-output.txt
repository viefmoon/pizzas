This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/rules/expo.mdc
.gitignore
.repomix/bundles.json
app.json
App.tsx
dependencies.md
docs/react-native-async-storage.md
docs/react-native-bluetooth-escpos-printer.md
docs/react-native-community-datetimepicker.md
docs/react-native-paper.md
docs/zustand-dev-guide.md
eas.json
expo-audio.md
index.ts
package.json
src/components/auth/LoginForm.tsx
src/components/common/GlobalSnackbar.tsx
src/screens/auth/LoginScreen.tsx
src/services/apiClient.ts
src/store/snackbarStore.ts
src/store/themeStore.ts
src/styles/colors.ts
src/styles/theme.ts
src/styles/typography.ts
src/types/auth.ts
src/types/theme.ts
tsconfig.json

================================================================
Files
================================================================

================
File: src/components/auth/LoginForm.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { TextInput, Button, HelperText, useTheme } from 'react-native-paper';

// Esquema de validación con Zod
const loginSchema = z.object({
  // Permitir email o username, refinar luego si es necesario validar formato específico
  emailOrUsername: z.string().min(1, 'El correo o nombre de usuario es requerido'),
  password: z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
});

// Inferir el tipo de los inputs desde el esquema Zod
type LoginFormInputs = z.infer<typeof loginSchema>;

interface LoginFormProps {
  onSubmit: (data: LoginFormInputs) => void;
  isLoading: boolean;
}

const LoginForm: React.FC<LoginFormProps> = ({ onSubmit, isLoading }) => {
  const theme = useTheme();
  const [secureTextEntry, setSecureTextEntry] = useState(true);

  const {
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormInputs>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      emailOrUsername: '',
      password: '',
    },
  });

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  // Estilos que dependen del tema
  const styles = StyleSheet.create({
    container: {
      width: '100%',
    },
    input: {
      marginBottom: 8,
      // backgroundColor: theme.colors.surface, // TextInput de Paper maneja su fondo basado en el modo y tema
    },
    button: {
      marginTop: 16,
    },
    helperText: {
      // El color del HelperText tipo 'error' se maneja por el tema
      marginBottom: 8,
    },
  });

  return (
    <View style={styles.container}>
      <Controller
        control={control}
        name="emailOrUsername"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Correo o Usuario"
              mode="outlined" // O 'flat' según preferencia de diseño
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              error={!!errors.emailOrUsername}
              style={styles.input}
              autoCapitalize="none"
              keyboardType="email-address" // Asume email como más común, pero permite username
              disabled={isLoading}
            />
            {/* Corrección: Usar && para renderizado condicional */}
            {errors.emailOrUsername && (
              <HelperText type="error" visible={!!errors.emailOrUsername} style={styles.helperText}>
                {errors.emailOrUsername?.message}
              </HelperText>
            )}
          </View>
        )}
      />

      <Controller
        control={control}
        name="password"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Contraseña"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              secureTextEntry={secureTextEntry}
              error={!!errors.password}
              style={styles.input}
              right={
                <TextInput.Icon
                  icon={secureTextEntry ? 'eye' : 'eye-off'}
                  onPress={toggleSecureEntry}
                  forceTextInputFocus={false} // Evita que el input gane foco al tocar el icono
                  color={errors.password ? theme.colors.error : undefined} // Cambia color del icono si hay error
                />
              }
              disabled={isLoading}
            />
            {/* Corrección: Usar && para renderizado condicional */}
            {errors.password && (
              <HelperText type="error" visible={!!errors.password} style={styles.helperText}>
                {errors.password?.message}
              </HelperText>
            )}
          </View>
        )}
      />

      <Button
        mode="contained"
        onPress={handleSubmit(onSubmit)}
        loading={isLoading}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? 'Ingresando...' : 'Ingresar'}
      </Button>
    </View>
  );
};

export default LoginForm;

================
File: src/components/common/GlobalSnackbar.tsx
================
import React from "react";
import { StyleSheet } from "react-native";
import { Snackbar } from "react-native-paper";
import { useAppTheme } from "../../styles/theme";
import { useSnackbarStore, SnackbarType } from "../../store/snackbarStore";

const GlobalSnackbar = () => {
  const theme = useAppTheme();

  // Obtener el estado del snackbar del store
  const { visible, message, type, duration, action, hideSnackbar } =
    useSnackbarStore();

  // Determinar la duración en base al tipo o al valor explícito pasado
  const getDuration = () => {
    // Si se proporciona una duración explícita, úsala
    if (duration) return duration;

    // De lo contrario, usa duraciones por defecto según el tipo
    switch (type) {
      case "error":
        return 4000; // Errores visibles por más tiempo
      case "success":
        return 2000; // Éxitos por tiempo medio
      case "info":
      case "warning":
        return 3000; // Info y advertencias por tiempo medio-largo
      default:
        return 4000; // Por defecto
    }
  };

  // Obtener el color de fondo según el tipo
  const getBackgroundColor = (type: SnackbarType) => {
    switch (type) {
      case "success":
        return theme.colors.success;
      case "error":
        return theme.colors.error;
      case "warning":
        return theme.colors.warning;
      case "info":
        return theme.colors.info;
      default:
        return undefined; // Usar el color por defecto de Paper
    }
  };

  // Obtener los estilos dinámicamente según el tipo
  const getStyles = () => {
    const backgroundColor = getBackgroundColor(type);

    return StyleSheet.create({
      snackbar: {
        backgroundColor,
      },
    });
  };

  const styles = getStyles();

  return (
    <Snackbar
      visible={visible}
      onDismiss={hideSnackbar}
      duration={getDuration()}
      style={styles.snackbar}
      action={action}
    >
      {message}
    </Snackbar>
  );
};

export default GlobalSnackbar;

================
File: src/screens/auth/LoginScreen.tsx
================
import React from "react";
import { StyleSheet, View } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { Text } from "react-native-paper";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useNavigation } from "@react-navigation/native"; // Para navegar después del login
import { useAppTheme } from "../../styles/theme"; // Importamos useAppTheme en lugar de useTheme

import LoginForm from "../../components/auth/LoginForm";
import apiClient from "../../services/apiClient"; // Cambiado a importación por defecto
import {
  AuthEmailLoginDto,
  LoginResponseDto,
  LoginFormInputs,
} from "../../types/auth";
import { useSnackbarStore } from "../../store/snackbarStore"; // Importamos el store del Snackbar global

const LoginScreen = () => {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const navigation = useNavigation(); // Hook de navegación
  const { showSnackbar } = useSnackbarStore(); // Usamos el Snackbar global

  // --- Lógica de Mutación (React Query) ---
  const loginMutation = useMutation<
    LoginResponseDto, // Tipo de la respuesta exitosa
    Error, // Tipo del error
    LoginFormInputs // Tipo de las variables de entrada (datos del formulario)
  >({
    mutationFn: async (loginData: LoginFormInputs) => {
      // Determinar si es email o username
      const isEmail = loginData.emailOrUsername.includes("@");
      const payload: AuthEmailLoginDto = {
        password: loginData.password,
        ...(isEmail
          ? { email: loginData.emailOrUsername }
          : { username: loginData.emailOrUsername }),
      };

      // Realizar la petición POST al endpoint de login
      const response = await apiClient.post<LoginResponseDto>(
        "/auth/email/login",
        payload
      );

      // Apisauce envuelve la respuesta. Verificamos si fue exitosa.
      if (!response.ok || !response.data) {
        // Intentar obtener un mensaje de error más específico si está disponible
        const apiError =
          (response.data as any)?.errors?.auth ||
          (response.data as any)?.errors?.password ||
          "credentialsIncorrect";
        // Mapear errores del backend a mensajes amigables
        const errorMessages: { [key: string]: string } = {
          credentialsIncorrect: "Usuario o contraseña incorrectos.",
          incorrectPassword: "La contraseña es incorrecta.",
          // Añadir otros mapeos si es necesario
        };
        throw new Error(errorMessages[apiError] || "Error al iniciar sesión.");
      }
      return response.data;
    },
    onSuccess: (data) => {
      console.log("Login successful:", data);

      // Mostrar mensaje de éxito con el Snackbar global
      showSnackbar({
        message: "¡Inicio de sesión exitoso!",
        type: "success",
      });

      // Invalidar queries relacionadas con el usuario si es necesario
      queryClient.invalidateQueries({ queryKey: ["user", "me"] });

      // Navegar a la pantalla principal de la aplicación
      // Reemplaza 'MainAppStack' con el nombre de tu stack/pantalla principal
      // navigation.reset({ index: 0, routes: [{ name: 'MainAppStack' }] });
      console.log("Navegación pendiente a la pantalla principal");
    },
    onError: (error) => {
      console.error("Login error:", error);

      // Mostrar mensaje de error con el Snackbar global
      showSnackbar({
        message: error.message || "Ocurrió un error inesperado.",
        type: "error",
        duration: 6000, // Duración más larga para errores
      });
    },
  });
  // --- Fin Lógica de Mutación ---

  const handleLogin = (data: LoginFormInputs) => {
    loginMutation.mutate(data); // Ejecutar la mutación con los datos del formulario
  };

  // Estilos que dependen del tema
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: "center",
      padding: 16,
      backgroundColor: theme.colors.background,
    },
    title: {
      textAlign: "center",
      marginBottom: 24,
      color: theme.colors.primary,
    },
  });

  return (
    <SafeAreaView style={styles.container}>
      <View>
        <Text variant="headlineMedium" style={styles.title}>
          Iniciar Sesión
        </Text>
        <LoginForm onSubmit={handleLogin} isLoading={loginMutation.isPending} />
      </View>
    </SafeAreaView>
  );
};

export default LoginScreen;

================
File: src/services/apiClient.ts
================
import { create } from 'apisauce';

// Define la URL base de tu API
const apiClient = create({
  baseURL: 'http://localhost:3000/', // URL base proporcionada
  headers: { 'Cache-Control': 'no-cache', 'Accept': 'application/json' },
  // Puedes añadir un timeout si lo necesitas, por ejemplo 10 segundos
  // timeout: 10000,
});

// --- Interceptores (Ejemplos Opcionales) ---

// Ejemplo: Añadir token de autenticación a todas las peticiones (si usas tokens)
// import EncryptedStorage from 'react-native-encrypted-storage'; // Asumiendo que guardas el token aquí
// apiClient.addAsyncRequestTransform(request => async () => {
//   try {
//     const token = await EncryptedStorage.getItem('authToken'); // Clave donde guardas el token
//     if (token) {
//       request.headers['Authorization'] = `Bearer ${token}`;
//     }
//   } catch (error) {
//     console.error("Error retrieving auth token:", error);
//   }
// });

// Ejemplo: Monitor para manejar errores comunes como 401 Unauthorized
// import { tuAuthStore } from '../store/authStore'; // Asumiendo un store Zustand para auth
// apiClient.addMonitor(response => {
//   if (response.status === 401 && !response.config?.url?.includes('/login')) { // Evita bucles en login
//     console.warn('Unauthorized access detected (401). Logging out.');
//     // Llama a tu función de logout global
//     // tuAuthStore.getState().logout();
//   }
//   // Puedes añadir más monitores para otros códigos de estado o problemas
//   if (!response.ok) {
//     console.error('API Request Problem:', response.problem, response);
//   }
// });

// --- Fin Interceptores ---

export default apiClient;

================
File: src/store/snackbarStore.ts
================
// Store para manejar el estado del Snackbar global
import { create } from "zustand";

export type SnackbarType = "default" | "success" | "error" | "warning" | "info";

interface SnackbarState {
  visible: boolean;
  message: string;
  type: SnackbarType;
  duration?: number;
  action?: {
    label: string;
    onPress: () => void;
  };

  // Acciones para manipular el estado
  showSnackbar: (params: {
    message: string;
    type?: SnackbarType;
    duration?: number;
    action?: { label: string; onPress: () => void };
  }) => void;
  hideSnackbar: () => void;
}

export const useSnackbarStore = create<SnackbarState>((set) => ({
  visible: false,
  message: "",
  type: "default",

  showSnackbar: ({ message, type = "default", duration, action }) => {
    set({
      visible: true,
      message,
      type,
      duration,
      action,
    });
  },

  hideSnackbar: () => {
    set({ visible: false });
  },
}));

================
File: src/store/themeStore.ts
================
// Store para manejar el estado del tema de la aplicación
import React from "react";
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useColorScheme } from "react-native";

import {
  ThemePreference,
  THEME_PREFERENCE_STORAGE_KEY,
  THEME_MODE,
} from "../types/theme";
import { lightTheme, darkTheme } from "../styles/theme";

interface ThemeState {
  themePreference: ThemePreference;
  activeTheme: typeof lightTheme | typeof darkTheme;
  isSystemDarkMode: boolean | null;
  setThemePreference: (preference: ThemePreference) => void;
  setSystemDarkMode: (isDark: boolean | null) => void;
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set, get) => ({
      // Valor por defecto: usar el tema del sistema
      themePreference: THEME_MODE.SYSTEM,
      // Por defecto comenzamos con el tema claro hasta que detectemos la preferencia del sistema
      activeTheme: lightTheme,
      // Estado que guarda la preferencia del sistema
      isSystemDarkMode: null,

      setThemePreference: (preference: ThemePreference) => {
        const { isSystemDarkMode } = get();

        // Actualiza la preferencia del usuario
        set({ themePreference: preference });

        // Determina el tema activo basado en la nueva preferencia
        if (preference === THEME_MODE.SYSTEM) {
          // Si es 'system', usa lo que indique el sistema
          set({ activeTheme: isSystemDarkMode ? darkTheme : lightTheme });
        } else {
          // Si es 'light' o 'dark', usa el tema correspondiente
          set({
            activeTheme:
              preference === THEME_MODE.DARK ? darkTheme : lightTheme,
          });
        }
      },

      setSystemDarkMode: (isDark: boolean | null) => {
        const { themePreference } = get();

        // Actualiza el estado de la preferencia del sistema
        set({ isSystemDarkMode: isDark });

        // Si la preferencia actual es 'system', actualiza el tema activo
        if (themePreference === THEME_MODE.SYSTEM && isDark !== null) {
          set({ activeTheme: isDark ? darkTheme : lightTheme });
        }
      },
    }),
    {
      name: THEME_PREFERENCE_STORAGE_KEY,
      storage: createJSONStorage(() => AsyncStorage),
      // Solo persistimos la preferencia del usuario, no el tema activo
      partialize: (state) => ({ themePreference: state.themePreference }),
    }
  )
);

// Hook personalizado para detectar cambios en el tema del sistema y actualizarlo en el store
export function useSystemThemeDetector() {
  const systemColorScheme = useColorScheme();
  const setSystemDarkMode = useThemeStore((state) => state.setSystemDarkMode);

  React.useEffect(() => {
    // Actualiza el estado con el tema detectado del sistema (null si no se puede detectar)
    const isDarkMode = systemColorScheme === "dark";
    setSystemDarkMode(isDarkMode);
  }, [systemColorScheme, setSystemDarkMode]);
}

================
File: src/styles/colors.ts
================
// Define las paletas de colores para temas claro y oscuro
// Estos colores son referenciales, deben ajustarse según la identidad de marca específica

// Paleta de colores para modo claro
export const lightColors = {
  // Colores principales
  primary: "#FF5722", // Rojo-naranja, color principal para la app de pizza
  primaryContainer: "#FFDACF",
  onPrimary: "#FFFFFF",
  onPrimaryContainer: "#401400",

  // Colores secundarios
  secondary: "#775652",
  secondaryContainer: "#FFDBDB",
  onSecondary: "#FFFFFF",
  onSecondaryContainer: "#2C1512",

  // Colores de acento/terciarios
  tertiary: "#705C2E",
  tertiaryContainer: "#FBDFA6",
  onTertiary: "#FFFFFF",
  onTertiaryContainer: "#261A00",

  // Colores de fondo y superficie
  background: "#FFFBFF",
  onBackground: "#201A19",
  surface: "#FFFBFF",
  onSurface: "#201A19",
  surfaceVariant: "#F5DDD8",
  onSurfaceVariant: "#534341",

  // Colores de estado/feedback
  error: "#BA1A1A",
  errorContainer: "#FFDAD6",
  onError: "#FFFFFF",
  onErrorContainer: "#410002",

  // Elementos de UI
  outline: "#857371",
  outlineVariant: "#D8C2BE",
  inverseSurface: "#362F2E",
  inverseOnSurface: "#FBEEE9",
  inversePrimary: "#FFB59E",

  // Otros colores semánticos
  success: "#4CAF50",
  successContainer: "#CCFFE3",
  warning: "#FB8C00",
  warningContainer: "#FFEACF",
  info: "#2196F3",
  infoContainer: "#D4E8FF",
};

// Paleta de colores para modo oscuro
export const darkColors = {
  // Colores principales
  primary: "#FFB59E", // Versión más clara del color principal
  primaryContainer: "#873100",
  onPrimary: "#5F1800",
  onPrimaryContainer: "#FFDACF",

  // Colores secundarios
  secondary: "#E7BDBA",
  secondaryContainer: "#5D3F3B",
  onSecondary: "#442926",
  onSecondaryContainer: "#FFDBDB",

  // Colores de acento/terciarios
  tertiary: "#DDC48C",
  tertiaryContainer: "#574419",
  onTertiary: "#3E2E04",
  onTertiaryContainer: "#FBDFA6",

  // Colores de fondo y superficie
  background: "#201A19",
  onBackground: "#EFDFDB",
  surface: "#201A19",
  onSurface: "#EFDFDB",
  surfaceVariant: "#534341",
  onSurfaceVariant: "#D8C2BE",

  // Colores de estado/feedback
  error: "#FFB4AB",
  errorContainer: "#93000A",
  onError: "#690005",
  onErrorContainer: "#FFDAD6",

  // Elementos de UI
  outline: "#A08C89",
  outlineVariant: "#534341",
  inverseSurface: "#EFDFDB",
  inverseOnSurface: "#201A19",
  inversePrimary: "#FF5722",

  // Otros colores semánticos
  success: "#7AE582",
  successContainer: "#00531B",
  warning: "#FFBD59",
  warningContainer: "#7F4600",
  info: "#A6CFFF",
  infoContainer: "#004880",
};

================
File: src/styles/theme.ts
================
// Configuración y exportación de temas para react-native-paper
import { MD3LightTheme, MD3DarkTheme, useTheme } from "react-native-paper";
import type { MD3Typescale } from "react-native-paper/lib/typescript/types";
import { lightColors, darkColors } from "./colors";
import { typography } from "./typography";

// Extender el tipo MD3Colors para incluir nuestros colores personalizados
declare global {
  namespace ReactNativePaper {
    interface MD3Colors {
      success: string;
      successContainer: string;
      warning: string;
      warningContainer: string;
      info: string;
      infoContainer: string;
    }
  }
}

// Define el espacio entre elementos UI (basado en Material Design)
const spacing = {
  xs: 4,
  s: 8,
  m: 16,
  l: 24,
  xl: 32,
  xxl: 40,
};

// Convertir nuestra tipografía a la estructura esperada por MD3Theme
const typescale: MD3Typescale = {
  default: typography.default,
  displayLarge: typography.displayLarge,
  displayMedium: typography.displayMedium,
  displaySmall: typography.displaySmall,
  headlineLarge: typography.headlineLarge,
  headlineMedium: typography.headlineMedium,
  headlineSmall: typography.headlineSmall,
  titleLarge: typography.titleLarge,
  titleMedium: typography.titleMedium,
  titleSmall: typography.titleSmall,
  bodyLarge: typography.bodyLarge,
  bodyMedium: typography.bodyMedium,
  bodySmall: typography.bodySmall,
  labelLarge: typography.labelLarge,
  labelMedium: typography.labelMedium,
  labelSmall: typography.labelSmall,
};

// Crea y extiende el tema claro de Paper con nuestras personalizaciones
export const lightTheme = {
  ...MD3LightTheme,
  colors: {
    ...MD3LightTheme.colors,
    ...lightColors,
  },
  fonts: typescale,
  spacing,
  // Puedes añadir más propiedades personalizadas aquí
  roundness: 8, // Radio de borde para componentes
};

// Crea y extiende el tema oscuro de Paper con nuestras personalizaciones
export const darkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...MD3DarkTheme.colors,
    ...darkColors,
  },
  fonts: typescale,
  spacing,
  // Puedes añadir más propiedades personalizadas aquí
  roundness: 8, // Radio de borde para componentes
};

// Tipo para los temas personalizados
export type AppTheme = typeof lightTheme;

// Helper para usar el tema en componentes (para tener autocompletado)
export const useAppTheme = () => useTheme() as AppTheme;

================
File: src/styles/typography.ts
================
// Define los estilos tipográficos según Material Design 3
// Estos valores se pueden ajustar según las necesidades específicas del diseño

import { MD3Type, MD3Typescale } from "react-native-paper/lib/typescript/types";

// Configuración de la tipografía según Material Design 3
export const typography: MD3Typescale = {
  default: {
    fontFamily: "sans-serif",
    fontWeight: "400",
    letterSpacing: 0,
  },
  // Fuentes de display (títulos grandes)
  displayLarge: {
    fontFamily: "sans-serif",
    fontSize: 57,
    fontWeight: "400",
    letterSpacing: 0,
    lineHeight: 64,
  },
  displayMedium: {
    fontFamily: "sans-serif",
    fontSize: 45,
    fontWeight: "400",
    letterSpacing: 0,
    lineHeight: 52,
  },
  displaySmall: {
    fontFamily: "sans-serif",
    fontSize: 36,
    fontWeight: "400",
    letterSpacing: 0,
    lineHeight: 44,
  },

  // Fuentes de título (headlines)
  headlineLarge: {
    fontFamily: "sans-serif",
    fontSize: 32,
    fontWeight: "400",
    letterSpacing: 0,
    lineHeight: 40,
  },
  headlineMedium: {
    fontFamily: "sans-serif",
    fontSize: 28,
    fontWeight: "400",
    letterSpacing: 0,
    lineHeight: 36,
  },
  headlineSmall: {
    fontFamily: "sans-serif",
    fontSize: 24,
    fontWeight: "400",
    letterSpacing: 0,
    lineHeight: 32,
  },

  // Fuentes para títulos de sección (title)
  titleLarge: {
    fontFamily: "sans-serif-medium",
    fontSize: 22,
    fontWeight: "500",
    letterSpacing: 0,
    lineHeight: 28,
  },
  titleMedium: {
    fontFamily: "sans-serif-medium",
    fontSize: 16,
    fontWeight: "500",
    letterSpacing: 0.15,
    lineHeight: 24,
  },
  titleSmall: {
    fontFamily: "sans-serif-medium",
    fontSize: 14,
    fontWeight: "500",
    letterSpacing: 0.1,
    lineHeight: 20,
  },

  // Fuentes para cuerpo de texto (body)
  bodyLarge: {
    fontFamily: "sans-serif",
    fontSize: 16,
    fontWeight: "400",
    letterSpacing: 0.15,
    lineHeight: 24,
  },
  bodyMedium: {
    fontFamily: "sans-serif",
    fontSize: 14,
    fontWeight: "400",
    letterSpacing: 0.25,
    lineHeight: 20,
  },
  bodySmall: {
    fontFamily: "sans-serif",
    fontSize: 12,
    fontWeight: "400",
    letterSpacing: 0.4,
    lineHeight: 16,
  },

  // Fuentes para etiquetas (label)
  labelLarge: {
    fontFamily: "sans-serif-medium",
    fontSize: 14,
    fontWeight: "500",
    letterSpacing: 0.1,
    lineHeight: 20,
  },
  labelMedium: {
    fontFamily: "sans-serif-medium",
    fontSize: 12,
    fontWeight: "500",
    letterSpacing: 0.5,
    lineHeight: 16,
  },
  labelSmall: {
    fontFamily: "sans-serif-medium",
    fontSize: 11,
    fontWeight: "500",
    letterSpacing: 0.5,
    lineHeight: 16,
  },
};

// Si necesitas adaptar para Android vs iOS, puedes exportar variantes específicas:
export const iosFontFamily = {
  regular: "System",
  medium: "System",
  light: "System",
  thin: "System",
};

export const androidFontFamily = {
  regular: "sans-serif",
  medium: "sans-serif-medium",
  light: "sans-serif-light",
  thin: "sans-serif-thin",
};

================
File: src/types/auth.ts
================
import { z } from 'zod';

// Esquema y tipo para el formulario de login (ya definido en LoginForm, pero puede ser centralizado)
export const loginSchema = z.object({
  emailOrUsername: z.string().min(1, 'El correo o nombre de usuario es requerido'),
  password: z.string().min(6, 'La contraseña debe tener al menos 6 caracteres'),
});
export type LoginFormInputs = z.infer<typeof loginSchema>;

// DTO para la petición de login al backend
// Basado en AuthEmailLoginDto del backend, permitiendo email o username
export const authEmailLoginDtoSchema = z.object({
  email: z.string().email().optional(),
  username: z.string().optional(),
  password: z.string(),
});
export type AuthEmailLoginDto = z.infer<typeof authEmailLoginDtoSchema>;

// Simplificación del tipo User basado en el backend para la respuesta
// Ajustar según los campos realmente necesarios en el frontend
const userSchema = z.object({
  id: z.string().uuid(), // Asumiendo UUID como string
  email: z.string().email().nullable(),
  username: z.string().nullable(),
  firstName: z.string().nullable(),
  lastName: z.string().nullable(),
  // Añadir otros campos relevantes si son necesarios (role, status, etc.)
  role: z.object({ id: z.number() }).optional(), // Asumiendo ID numérico para rol
});
export type User = z.infer<typeof userSchema>;


// DTO para la respuesta del login del backend
export const loginResponseDtoSchema = z.object({
  token: z.string(),
  refreshToken: z.string(),
  tokenExpires: z.number(), // O z.string() si la API devuelve una fecha/string
  user: userSchema,
});
export type LoginResponseDto = z.infer<typeof loginResponseDtoSchema>;

// Podrías añadir aquí otros DTOs y tipos relacionados con auth (register, forgot password, etc.)

================
File: src/types/theme.ts
================
// Define los tipos para el sistema de temas de la aplicación
import { z } from "zod";

// Definición de las posibles preferencias de tema
export const themePreferenceSchema = z.enum(["light", "dark", "system"]);
export type ThemePreference = z.infer<typeof themePreferenceSchema>;

// Clave para almacenar la preferencia de tema en AsyncStorage
export const THEME_PREFERENCE_STORAGE_KEY = "app:theme_preference";

// Valores constantes para facilitar el uso en el código
export const THEME_MODE = {
  LIGHT: "light",
  DARK: "dark",
  SYSTEM: "system",
} as const;

================
File: .gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: App.tsx
================
import React, { useEffect } from "react";
import { StatusBar } from "expo-status-bar";
import { StyleSheet, Text, View } from "react-native";
import { PaperProvider } from "react-native-paper";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useThemeStore, useSystemThemeDetector } from "./src/store/themeStore";
import GlobalSnackbar from "./src/components/common/GlobalSnackbar";
import LoginScreen from "./src/screens/auth/LoginScreen";

// Crear una instancia de QueryClient para React Query
const queryClient = new QueryClient();

export default function App() {
  // Usar el tema global de la aplicación
  const activeTheme = useThemeStore((state) => state.activeTheme);
  const isDarkMode = activeTheme.dark;

  // Detectar y actualizar el tema del sistema
  useSystemThemeDetector();

  return (
    <SafeAreaProvider>
      <QueryClientProvider client={queryClient}>
        <PaperProvider theme={activeTheme}>
          {/* Ajustar StatusBar según el tema */}
          <StatusBar style={isDarkMode ? "light" : "dark"} />

          {/* Contenido principal de la aplicación */}
          <LoginScreen />

          {/* Snackbar global accesible desde cualquier parte */}
          <GlobalSnackbar />
        </PaperProvider>
      </QueryClientProvider>
    </SafeAreaProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#fff",
    alignItems: "center",
    justifyContent: "center",
  },
});

================
File: dependencies.md
================
## `@expo/vector-icons`

**Propósito General:** Proporciona un conjunto amplio y popular de iconos vectoriales (`FontAwesome`, `Material Icons`, `Ionicons`, etc.) listos para usar en Expo.

**Uso en tu App:** Fundamental para la interfaz de usuario (UI). Los usarás para:
*   Botones (ej: "Añadir Pedido", "Editar Menú", "Confirmar", "Cancelar").
*   Elementos de navegación (íconos en pestañas, menú lateral/drawer).
*   Indicadores visuales (estado del pedido: pendiente, en cocina, listo, entregado).
*   Iconos junto a elementos de menú, categorías, opciones de configuración.
*   Mejorar la usabilidad y el atractivo visual general de la app.

## `@hookform/resolvers`

**Propósito General:** Actúa como un puente entre `react-hook-form` y librerías de validación de esquemas como `Zod`, `Yup`, etc.

**Uso en tu App:** Se usará junto con `react-hook-form` y `zod` para validar los datos introducidos en los formularios.
*   Ejemplo: Definirás un esquema con `zod` para un nuevo plato del menú (nombre obligatorio, precio numérico positivo, descripción opcional). Este resolver conectará ese esquema a tu formulario de "Añadir Plato", mostrando errores automáticamente si el usuario introduce datos inválidos. Lo mismo aplicará para formularios de pedidos, datos de clientes, configuración, etc.

## `@react-native-async-storage/async-storage`

**Propósito General:** Almacenamiento persistente simple de clave-valor en el dispositivo (similar al `localStorage` en web, pero asíncrono).

**Uصo en tu App:**
*   Guardar preferencias del usuario (tema claro/oscuro, impresora predeterminada).
*   Guardar tokens de autenticación o información básica de sesión (aunque para tokens sensibles, considera opciones más seguras si es necesario).

## `@react-native-community/datetimepicker`

**Propósito General:** Muestra el selector nativo de fecha y hora del sistema operativo (iOS/Android).

**Uso en tu App:**
*   Permitir al usuario seleccionar la fecha y hora deseada para un pedido (recogida o entrega).
*   Filtrar pedidos o reportes por un rango de fechas.
*   Establecer horarios de apertura/cierre del restaurante en la configuración.

## `@react-native-community/netinfo`

**Propósito General:** Detecta el estado y tipo de conexión de red del dispositivo (conectado/desconectado, WiFi/Celular).

**Uso en tu App:**
*   Verificar si hay conexión antes de intentar sincronizar pedidos con el servidor backend.
*   Mostrar un indicador visual al usuario si está offline.
*   Deshabilitar funcionalidades que requieran conexión (ej: realizar un nuevo pedido online, buscar clientes en la base de datos central).
*   Quizás habilitar un modo offline básico si la app lo soporta.

## `@react-navigation/drawer`

**Propósito General:** Implementa un patrón de navegación de tipo "menú lateral deslizable" (Drawer).

**Uso en tu App:** Probablemente será tu navegación principal. El menú lateral podría contener enlaces a secciones como:
*   Panel Principal / Dashboard
*   Pedidos Pendientes
*   Historial de Pedidos
*   Gestión de Menú
*   Clientes
*   Reportes
*   Configuración
*   Cerrar Sesión

## `@react-navigation/native`

**Propósito General:** El núcleo fundamental de la librería de navegación `React Navigation`. Proporciona el contexto y los hooks básicos para la navegación.

**Uso en tu App:** Es la base sobre la que funcionan `@react-navigation/drawer` y `@react-navigation/native-stack`. No interactuarás directamente con ella tanto como con los navegadores específicos, pero es indispensable.

## `@react-navigation/native-stack`

**Propósito General:** Implementa un patrón de navegación de tipo "pila" (Stack), donde las pantallas se apilan una encima de otra y puedes retroceder.

**Uso en tu App:** Se usará dentro de las secciones definidas en el Drawer o como navegador principal si no usas Drawer.
*   Ejemplo: Desde la lista de "Pedidos Pendientes" (pantalla 1), al tocar un pedido, navegas a "Detalles del Pedido" (pantalla 2). Desde ahí, quizás a "Editar Pedido" (pantalla 3). El Stack te permite volver atrás fácilmente. Indispensable para flujos de tareas detalladas.

## `@tanstack/react-query` (React Query)

**Propósito General:** Una librería muy potente para gestionar el "estado del servidor": fetching, caching, sincronización y actualización de datos remotos.

**Uso en tu App:** Fundamental para interactuar con tu API backend.
*   **Fetching:** Obtener listas de pedidos, detalles de un pedido, menú, clientes, etc., manejando automáticamente estados de carga (loading) y error.
*   **Caching:** Guarda los datos obtenidos para no tener que pedirlos repetidamente, mejorando la velocidad y reduciendo el uso de red.
*   **Sincronización:** Mantiene los datos de la app actualizados con el servidor (ej: puede refetchear automáticamente la lista de pedidos cuando la app vuelve a estar activa).
*   **Mutations:** Manejar operaciones de escritura (crear pedido, actualizar estado, eliminar plato del menú) con gestión de estados y invalidación automática de caché (ej: después de crear un pedido, invalida el caché de la lista de pedidos para que se actualice).

## `apisauce`

**Propósito General:** Un wrapper ligero sobre `axios` (un cliente HTTP popular) que simplifica la realización de peticiones API y el manejo de respuestas y errores comunes.

**Uso en tu App:** Será la librería que uses (probablemente dentro de las funciones que llames con React Query) para comunicarte con tu API backend.
*   Definir la URL base de tu API.
*   Configurar cabeceras (como tokens de autenticación).
*   Realizar peticiones GET (obtener datos), POST (crear), PUT/PATCH (actualizar), DELETE (eliminar).
*   Manejar de forma estandarizada las respuestas (éxito/error).

## `date-fns`

**Propósito General:** Una librería moderna y completa para manipulación y formateo de fechas y horas.

**Uso en tu App:**
*   Formatear fechas y horas para mostrarlas al usuario de manera legible (ej: "15 Jul 2024, 10:30 AM", "hace 5 minutos").
*   Calcular diferencias de tiempo (ej: ¿cuánto tiempo lleva un pedido pendiente?).
*   Parsear fechas recibidas de la API.
*   Realizar comparaciones de fechas (ej: para filtros).

## `expo-audio`

**Propósito General:** Permite grabar y reproducir audio.

**Uso en tu App:**
*   Caso principal: Reproducir un sonido de notificación claro y distintivo cuando llega un nuevo pedido. Esto es crucial en un ambiente de restaurante ruidoso.
*   Menos común: Permitir grabar notas de voz asociadas a un pedido (ej: instrucciones especiales del cliente o notas internas de cocina), aunque la entrada de texto suele ser más práctica.

## `expo-file-system`

**Propósito General:** Proporciona acceso al sistema de archivos local del dispositivo.

**Uso en tu App:**
*   Guardar archivos generados, como recibos en PDF creados con `expo-print` antes de compartirlos o imprimirlos.
*   Descargar y almacenar temporalmente imágenes o reportes del servidor.
*   Posiblemente para caching de assets grandes si es necesario.

## `expo-image`

**Propósito General:** Un componente de imagen más avanzado y performante que el `Image` de React Native, con mejor manejo de caché y formatos (como WebP).

**Uso en tu App:**
*   Mostrar imágenes de los platos en el menú de forma eficiente.
*   Mostrar logos o imágenes de marca.
*   Potencialmente, fotos de perfil de empleados o clientes (si aplica).

## `expo-image-picker`

**Propósito General:** Permite al usuario seleccionar imágenes o videos de la galería del dispositivo o tomar una foto/video nuevo con la cámara.

**Uso en tu App:**
*   Permitir al personal del restaurante añadir o actualizar fotos de los platos del menú directamente desde la app.
*   Potencialmente, adjuntar una foto a un pedido para documentar un problema o una entrega especial.

## `expo-notifications`

**Propósito General:** Gestionar notificaciones push (remotas, enviadas desde un servidor) y locales (programadas desde la app).

**Uso en tu App:** Esencial para la comunicación en tiempo real.
*   **Notificaciones Push:** Alertar instantáneamente al personal (en la app) cuando llega un nuevo pedido online.
*   **Notificaciones Push/Locales:** Informar sobre cambios de estado importantes de un pedido (ej: "Pedido #123 listo para recoger").
*   Alertas sobre inventario bajo (si la app gestiona inventario).
*   Recordatorios para el personal.

## `expo-print`

**Propósito General:** Permite generar documentos (usualmente HTML formateado como PDF) y enviarlos al sistema de impresión del dispositivo.

**Uso en tu App:**
*   Generar recibos/tickets para los pedidos.
*   Generar reportes de ventas o inventario en formato imprimible (PDF).
*   Importante: Para imprimir directamente en impresoras térmicas de tickets (comunes en restaurantes), necesitarás combinar esto o usar directamente `react-native-bluetooth-escpos-printer`. `expo-print` es más para impresión estándar (AirPrint, Android Print Service).

## `lottie-react-native`

**Propósito General:** Renderiza animaciones creadas en Adobe After Effects (exportadas como JSON con Bodymovin/Lottie).

**Uso en tu App:**
*   Mejorar la experiencia de usuario (UX) con animaciones fluidas.
*   Indicadores de carga atractivos mientras se obtienen datos.
*   Animaciones de éxito (ej: al confirmar un pedido).
*   Pequeñas animaciones para feedback visual en interacciones.

## `react-hook-form`

**Propósito General:** Una librería popular para manejar el estado, la validación y el envío de formularios en React/React Native de manera eficiente y sencilla usando hooks.

**Uso en tu App:**
*   Gestionar todos los formularios de entrada de datos: crear/editar pedidos, añadir/modificar platos del menú, registrar clientes, configurar ajustes.
*   Controlar los valores de los inputs, manejar el estado de envío (`submitting`), y mostrar errores de validación (junto con `@hookform/resolvers` y `zod`). Simplifica enormemente la lógica de formularios complejos.

## `react-native-bluetooth-escpos-printer`

**Propósito General:** Librería específica para comunicarse directamente con impresoras térmicas de recibos que usan el protocolo ESC/POS (muy común en TPVs y cocinas) a través de Bluetooth.

**Uso en tu App:** Crucial para la funcionalidad de impresión de tickets.
*   Descubrir y conectar con impresoras Bluetooth cercanas.
*   Enviar comandos ESC/POS para imprimir texto formateado (negrita, tamaño), códigos de barras/QR, imágenes simples y cortar el papel en los recibos de pedidos (para cocina, cliente, etc.).
*   Esta es la librería que probablemente usarás para la impresión directa en las impresoras del restaurante.

## `react-native-gesture-handler`

**Propósito General:** Proporciona una API más potente y nativa para manejar gestos táctiles (taps, swipes, pans, etc.).

**Uso en tu App:** Es una dependencia requerida por `react-navigation` (especialmente para el Drawer y transiciones suaves). También la podrías usar para implementar gestos personalizados, como deslizar un elemento de la lista para revelar opciones (ej: "Marcar como listo", "Eliminar").

## `react-native-paper`

**Propósito General:** Una librería de componentes UI de alta calidad que implementa las directrices de Material Design.

**Uso en tu App:**
*   Proporciona componentes listos para usar y estilizados: `Button`, `Card`, `TextInput`, `Modal`, `Appbar`, `DataTable`, etc.
*   Acelera enormemente el desarrollo de la interfaz de usuario.
*   Asegura una apariencia consistente y profesional (siguiendo Material Design).
*   Ofrece temas (`theming`) para personalizar colores y fuentes fácilmente.

## `react-native-reanimated`

**Propósito General:** Una librería avanzada para crear animaciones fluidas y performantes, ejecutando la lógica de animación en el hilo nativo.

**Uso en tu App:** Es una dependencia requerida por `react-native-gesture-handler` y `react-navigation` para animaciones suaves (como la apertura del Drawer o las transiciones de pantalla). También puedes usarla directamente para crear animaciones personalizadas complejas si es necesario.

## `react-native-safe-area-context`

**Propósito General:** Proporciona una forma de asegurar que tu contenido no se solape con elementos de la interfaz del sistema operativo (como la barra de estado, el notch en iPhones, las barras de navegación).

**Uso en tu App:** Indispensable para un diseño correcto en todos los dispositivos. Usarás su `SafeAreaView` para envolver tus pantallas o vistas principales y evitar que los elementos importantes queden ocultos.

## `react-native-screens`

**Propósito General:** Optimiza el uso de memoria y el rendimiento de la navegación utilizando primitivas de pantalla nativas.

**Uso en tu App:** Es una dependencia requerida por `react-navigation` para mejorar el rendimiento, especialmente en apps con muchas pantallas.

## `zod`

**Propósito General:** Una librería para declarar esquemas y validar datos en TypeScript/JavaScript. Es muy potente y tiene excelente integración con TypeScript.

**Uso en tu App:**
*   Definir la "forma" esperada de tus datos (objetos de pedido, items de menú, respuestas de API).
*   Validar los datos de los formularios (usando `@hookform/resolvers` y `react-hook-form`).
*   Opcionalmente, validar las respuestas recibidas de tu API para asegurar que cumplen el contrato esperado. Aumenta la robustez de tu app.

## `zustand`

**Propósito General:** Una librería de gestión de estado global pequeña, rápida y escalable, basada en hooks. Es más simple que Redux.

**Uso en tu App:** Para gestionar el estado que necesita ser compartido entre diferentes componentes o pantallas no directamente relacionadas.
*   Estado de autenticación del usuario (logueado/no logueado, datos del usuario).
*   Configuración global de la app (ej: restaurante/sucursal seleccionada).
*   Quizás el estado de un "carrito" temporal antes de confirmar un pedido.
*   Estado de la conexión de la impresora Bluetooth.

## `expo-dev-client`

**Propósito General:** Te permite crear "builds de desarrollo" de tu app Expo. Estas builds incluyen el código nativo necesario para usar librerías que tienen partes nativas (como `react-native-bluetooth-escpos-printer`) durante el desarrollo, sin necesidad de usar la app Expo Go (que tiene un conjunto limitado de APIs nativas).

**Uso en tu Desarrollo:** Fundamental porque estás usando `react-native-bluetooth-escpos-printer` y otras librerías comunitarias con código nativo. Necesitarás crear una build de desarrollo (`eas build --profile development` o `npx expo run:android`/`npx expo run:ios`) e instalarla en tu dispositivo/emulador para poder probar esas funcionalidades nativas mientras desarrollas.

================
File: docs/react-native-async-storage.md
================
# react-native-async-storage/async-storage

## Uso

Async Storage solo puede almacenar datos de tipo cadena (string). Para almacenar datos de objetos, primero necesitas serializarlos. Para datos que pueden ser serializados a JSON, puedes usar `JSON.stringify()` al guardar los datos y `JSON.parse()` al cargarlos.

### Importación

```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';
```

### Almacenamiento de datos

`setItem()` se utiliza tanto para agregar un nuevo elemento de datos (cuando no existen datos para la clave dada) como para modificar un elemento existente (cuando existen datos previos para la clave dada).

#### Almacenamiento de valor de cadena

```javascript
const storeData = async (value) => {
  try {
    await AsyncStorage.setItem('my-key', value);
  } catch (e) {
    // error al guardar
  }
};
```

#### Almacenamiento de valor de objeto

```javascript
const storeData = async (value) => {
  try {
    const jsonValue = JSON.stringify(value);
    await AsyncStorage.setItem('my-key', jsonValue);
  } catch (e) {
    // error al guardar
  }
};
```

### Lectura de datos

`getItem` devuelve una promesa que se resuelve con el valor almacenado cuando se encuentran datos para la clave dada, o devuelve `null` en caso contrario.

#### Lectura de valor de cadena

```javascript
const getData = async () => {
  try {
    const value = await AsyncStorage.getItem('my-key');
    if (value !== null) {
      // valor previamente almacenado
    }
  } catch (e) {
    // error al leer el valor
  }
};
```

#### Lectura de valor de objeto

```javascript
const getData = async () => {
  try {
    const jsonValue = await AsyncStorage.getItem('my-key');
    return jsonValue != null ? JSON.parse(jsonValue) : null;
  } catch (e) {
    // error al leer el valor
  }
};
```

## API

### `getItem`

Obtiene un valor de cadena para una clave dada. Esta función puede devolver un valor de cadena para una clave existente o devolver `null` en caso contrario.

Para almacenar un valor de objeto, necesitas deserializarlo, por ejemplo, usando `JSON.parse()`.

Nota (legado): puedes usar un callback opcional como alternativa a la promesa devuelta.

**Firma:**

```javascript
static getItem(key: string, [callback]: ?(error: ?Error, result: ?string) => void): Promise
```

**Devuelve:**

Promesa que se resuelve con un valor de cadena, si existe una entrada para la clave dada, o `null` en caso contrario.

La promesa también puede ser rechazada en caso de error de almacenamiento subyacente.

**Ejemplo:**

```javascript
getMyStringValue = async () => {
  try {
    return await AsyncStorage.getItem('@key')
  } catch(e) {
    // error de lectura
  }

  console.log('Hecho.')
}

getMyObject = async () => {
  try {
    const jsonValue = await AsyncStorage.getItem('@key')
    return jsonValue != null ? JSON.parse(jsonValue) : null
  } catch(e) {
    // error de lectura
  }

  console.log('Hecho.')
}
```

### `setItem`

Establece un valor de cadena para una clave dada. Esta operación puede modificar una entrada existente, si existía para la clave dada, o agregar una nueva en caso contrario.

Para almacenar un valor de objeto, necesitas serializarlo, por ejemplo, usando `JSON.stringify()`.

Nota (legado): puedes usar un callback opcional como alternativa a la promesa devuelta.

**Firma:**

```javascript
static setItem(key: string, value: string, [callback]: ?(error: ?Error) => void): Promise
```

**Devuelve:**

Promesa que se resuelve cuando se completa la operación de establecimiento.

La promesa también puede ser rechazada en caso de error de almacenamiento subyacente.

**Ejemplo:**

```javascript
setStringValue = async (value) => {
  try {
    await AsyncStorage.setItem('key', value)
  } catch(e) {
    // error al guardar
  }

  console.log('Hecho.')
}

setObjectValue = async (value) => {
  try {
    const jsonValue = JSON.stringify(value)
    await AsyncStorage.setItem('key', jsonValue)
  } catch(e) {
    // error al guardar
  }

  console.log('Hecho.')
}
```

### `mergeItem`

Fusiona un valor existente almacenado bajo una clave, con un nuevo valor, asumiendo que ambos valores son JSON stringificados.

**Firma:**

```javascript
static mergeItem(key: string, value: string, [callback]: ?(error: ?Error) => void): Promise
```

**Devuelve:**

Promesa con los datos fusionados, si existen, `null` en caso contrario.

**Ejemplo:**

```javascript
const USER_1 = {
  name: 'Tom',
  age: 20,
  traits: {
    hair: 'black',
    eyes: 'blue'
  }
}

const USER_2 = {
  name: 'Sarah',
  age: 21,
  hobby: 'cars',
  traits: {
    eyes: 'green',
  }
}


mergeUsers = async () => {
  try {
    //guardar primer usuario
    await AsyncStorage.setItem('@MyApp_user', JSON.stringify(USER_1))

    // fusionar USER_2 en USER_1 guardado
    await AsyncStorage.mergeItem('@MyApp_user', JSON.stringify(USER_2))

    // leer elemento fusionado
    const currentUser = await AsyncStorage.getItem('@MyApp_user')

    console.log(currentUser)

    // resultado en consola:
    // {
    //   name: 'Sarah',
    //   age: 21,
    //   hobby: 'cars',
    //   traits: {
    //     eyes: 'green',
    //     hair: 'black'
    //   }
    // }
  } catch(e) {
     // error
  }
}
```

### `removeItem`

Elimina el elemento para una clave, invoca el callback (opcional) una vez completado.

**Firma:**

```javascript
static removeItem(key: string, [callback]: ?(error: ?Error) => void): Promise
```

**Devuelve:**

Objeto Promesa.

**Ejemplo:**

```javascript
removeValue = async () => {
  try {
    await AsyncStorage.removeItem('@MyApp_key')
  } catch(e) {
    // error al eliminar
  }

  console.log('Hecho.')
}
```

### `getAllKeys`

Devuelve todas las claves conocidas por tu aplicación, para todos los llamadores, bibliotecas, etc. Una vez completado, invoca el callback con errores (si los hay) y un array de claves.

**Firma:**

```javascript
static getAllKeys([callback]: ?(error: ?Error, keys: ?Array<string>) => void): Promise
```

**Devuelve:**

Objeto Promesa.

**Ejemplo:**

```javascript
getAllKeys = async () => {
  let keys = []
  try {
    keys = await AsyncStorage.getAllKeys()
  } catch(e) {
    // error al leer la clave
  }

  console.log(keys)
  // ejemplo de resultado en consola:
  // ['@MyApp_user', '@MyApp_key']
}
```

### `multiGet`

Obtiene múltiples pares clave-valor para un array dado de claves en un lote. Una vez completado, invoca el callback con errores (si los hay) y los resultados.

**Firma:**

```javascript
static multiGet(keys: Array<string>, [callback]: ?(errors: ?Array<Error>, result: ?Array<Array<string>>) => void): Promise
```

**Devuelve:**

Promesa de un array con los pares clave-valor correspondientes encontrados, almacenados como un array `[key, value]`.

**Ejemplo:**

```javascript
getMultiple = async () => {

  let values
  try {
    values = await AsyncStorage.multiGet(['@MyApp_user', '@MyApp_key'])
  } catch(e) {
    // error de lectura
  }
  console.log(values)

  // ejemplo de salida en consola:
  // [ ['@MyApp_user', 'myUserValue'], ['@MyApp_key', 'myKeyValue'] ]
}
```

### `multiSet`

Almacena múltiples pares clave-valor en un lote. Una vez completado, se llamará al callback con cualquier error.

**Firma:**

```javascript
static multiSet(keyValuePairs: Array<Array<string>>, [callback]: ?(errors: ?Array<Error>) => void): Promise
```

**Devuelve:**

Objeto Promesa.

**Ejemplo:**

```javascript
multiSet = async () => {
  const firstPair = ["@MyApp_user", "value_1"]
  const secondPair = ["@MyApp_key", "value_2"]
  try {
    await AsyncStorage.multiSet([firstPair, secondPair])
  } catch(e) {
    //error al guardar
  }

  console.log("Hecho.")
}
```

### `multiMerge`

Fusión múltiple de valores existentes y nuevos en un lote. Asume que los valores son JSON stringificados. Una vez completado, invoca el callback con errores (si los hay).

**Firma:**

```javascript
static multiMerge(keyValuePairs: Array<Array<string>>, [callback]: ?(errors: ?Array<Error>) => void): Promise
```

**Devuelve:**

Objeto Promesa.

**Ejemplo:**

```javascript
const USER_1 = {
  name: 'Tom',
  age: 30,
  traits: {hair: 'brown'},
};

const USER_1_DELTA = {
  age: 31,
  traits: {eyes: 'blue'},
};

const USER_2 = {
  name: 'Sarah',
  age: 25,
  traits: {hair: 'black'},
};

const USER_2_DELTA = {
  age: 26,
  traits: {hair: 'green'},
};


const multiSet = [
  ["@MyApp_USER_1", JSON.stringify(USER_1)],
  ["@MyApp_USER_2", JSON.stringify(USER_2)]
]

const multiMerge = [
  ["@MyApp_USER_1", JSON.stringify(USER_1_DELTA)],
  ["@MyApp_USER_2", JSON.stringify(USER_2_DELTA)]
]


mergeMultiple = async () => {
  let parsedCurrentlyMerged

  try {
    await AsyncStorage.multiSet(multiSet)
    await AsyncStorage.multiMerge(multiMerge)
    const currentlyMerged = await AsyncStorage.multiGet(['@MyApp_USER_1', '@MyApp_USER_2'])
    parsedCurrentlyMerged = currentlyMerged.map(([key, value]) => [
      key,
      JSON.parse(value),
    ]);
  } catch(e) {
    // error
  }

  console.log(
    'parsedCurrentlyMerged',
    JSON.stringify(parsedCurrentlyMerged, null, 2),
  );
  // salida en consola:
  /*
  [
    [
      "@MyApp_USER_1",
      {
        "name": "Tom",
        "age": 31,
        "traits": {
          "hair": "brown",
          "eyes": "blue"
        }
      }
    ],
    [
      "@MyApp_USER_2",
      {
        "name": "Sarah",
        "age": 26,
        "traits": {
          "hair": "green"
        }
      }
    ]
  ]
  */
}
```

### `multiRemove`

Borra múltiples entradas clave-valor para un array dado de claves en un lote. Una vez completado, invoca un callback con errores (si los hay).

**Firma:**

```javascript
static multiRemove(keys: Array<string>, [callback]: ?(errors: ?Array<Error>) => void)
```

**Devuelve:**

Objeto Promesa.

**Ejemplo:**

```javascript
removeFew = async () => {
  const keys = ['@MyApp_USER_1', '@MyApp_USER_2']
  try {
    await AsyncStorage.multiRemove(keys)
  } catch(e) {
    // error al eliminar
  }

  console.log('Hecho')
}
```

### `clear`

Elimina todos los datos de AsyncStorage, para todos los clientes, bibliotecas, etc. Probablemente quieras usar `removeItem` o `multiRemove` para borrar solo las claves de tu aplicación.

**Firma:**

```javascript
static clear([callback]: ?(error: ?Error) => void): Promise
```

**Devuelve:**

Objeto Promesa.

**Ejemplo:**

```javascript
clearAll = async () => {
  try {
    await AsyncStorage.clear()
  } catch(e) {
    // error al borrar
  }

  console.log('Hecho.')
}
```

### `useAsyncStorage`

Nota: Una interfaz similar a los hooks con la que estamos experimentando. Esto cambiará en el futuro cercano para aprovechar completamente la API de Hooks, así que siéntete libre de seguir esta discusión para obtener más información.

`useAsyncStorage` devuelve un objeto que expone todos los métodos que te permiten interactuar con el valor almacenado.

**Firma:**

```javascript
static useAsyncStorage(key: string): {
  getItem: (
    callback?: ?(error: ?Error, result: string | null) => void,
  ) => Promise<string | null>,
  setItem: (
    value: string,
    callback?: ?(error: ?Error) => void,
  ) => Promise<null>,
  mergeItem: (
    value: string,
    callback?: ?(error: ?Error) => void,
  ) => Promise<null>,
  removeItem: (callback?: ?(error: ?Error) => void) => Promise<null>,
}
```

**Devuelve:**

objeto

**Ejemplo Específico:**

Puedes reemplazar tu `App.js` con lo siguiente para verlo en acción.

```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { useAsyncStorage } from '@react-native-async-storage/async-storage';

export default function App() {
  const [value, setValue] = useState('value');
  const { getItem, setItem } = useAsyncStorage('@storage_key');

  const readItemFromStorage = async () => {
    const item = await getItem();
    setValue(item);
  };

  const writeItemToStorage = async newValue => {
    await setItem(newValue);
    setValue(newValue);
  };

  useEffect(() => {
    readItemFromStorage();
  }, []);

  return (
    <View style={{ margin: 40 }}>
      <Text>Valor actual: {value}</Text>
      <TouchableOpacity
        onPress={() =>
          writeItemToStorage(
            Math.random()
              .toString(36)
              .substr(2, 5)
          )
        }
      >
        <Text>Actualizar valor</Text>
      </TouchableOpacity>
    </View>
  );
}
```

En este ejemplo:

-   Al montar, leemos el valor en `@storage_key` y lo guardamos en el estado bajo `value`.
-   Al presionar "actualizar valor", se genera una nueva cadena, se guarda en async storage y en el estado del componente.
-   Intenta recargar tu aplicación: verás que el último valor todavía se está leyendo desde async storage.

## Límites de almacenamiento conocidos

### Android

AsyncStorage para Android utiliza SQLite como backend de almacenamiento. Si bien tiene sus propios límites de tamaño, el sistema Android también tiene dos límites conocidos: el tamaño total de almacenamiento y el límite de tamaño por entrada.

-   **Tamaño total de almacenamiento:** está limitado a 6 MB por defecto. Puedes aumentar este tamaño especificando un nuevo tamaño mediante una bandera de característica.
-   **Por entrada:** está limitado por el tamaño de un `WindowCursor`, un búfer utilizado para leer datos de SQLite. Actualmente su tamaño es de alrededor de 2 MB. Esto significa que el elemento único leído a la vez no puede ser mayor de 2 MB. No hay una solución alternativa compatible desde AsyncStorage. Sugerimos mantener tus datos por debajo de eso, dividiéndolos en muchas entradas, en lugar de una entrada masiva. Aquí es donde las API `multiGet` y `multiSet` pueden brillar.

================
File: docs/react-native-bluetooth-escpos-printer.md
================
Usage and APIs
BluetoothManager
BluetoothManager is the module for Bluetooth service management, supports Bluetooth status check, enable/disable Bluetooth service, scan devices, connect/unpair devices.

isBluetoothEnabled ==> async function, checks whether Bluetooth service is enabled. //TODO: consider to return the the devices information already bound and paired here..
     BluetoothManager.isBluetoothEnabled().then((enabled)=> {
                alert(enabled) // enabled ==> true /false
            }, (err)=> {
                alert(err)
            });
enableBluetooth ==> diff + ANDROID ONLY async function, enables the bluetooth service, returns the devices information already bound and paired. diff - IOS would just resovle with nil
BluetoothManager.enableBluetooth().then((r)=>{
                var paired = [];
                if(r && r.length>0){
                    for(var i=0;i<r.length;i++){
                        try{
                            paired.push(JSON.parse(r[i])); // NEED TO PARSE THE DEVICE INFORMATION
                        }catch(e){
                            //ignore
                        }
                    }
                }
                console.log(JSON.stringify(paired))
            },(err)=>{
               alert(err)
           });
disableBluetooth ==> diff + ANDROID ONLY async function ,disables the bluetooth service. diff - IOS would just resovle with nil
BluetoothManager.disableBluetooth().then(()=>{
            // do something.
          },(err)=>{alert(err)});
scanDevices ==> async function , scans the bluetooth devices, returns devices found and paired after scan finish. Event [BluetoothManager.EVENT_DEVICE_ALREADY_PAIRED] would be emitted with devices bound; event [BluetoothManager.EVENT_DEVICE_FOUND] would be emitted (many time) as long as new devices found.
samples with events:

 DeviceEventEmitter.addListener(
            BluetoothManager.EVENT_DEVICE_ALREADY_PAIRED, (rsp)=> {
                this._deviceAlreadPaired(rsp) // rsp.devices would returns the paired devices array in JSON string.
            });
        DeviceEventEmitter.addListener(
            BluetoothManager.EVENT_DEVICE_FOUND, (rsp)=> {
                this._deviceFoundEvent(rsp) // rsp.devices would returns the found device object in JSON string
            });
samples with scanDevices function

BluetoothManager.scanDevices()
            .then((s)=> {
                var ss = JSON.parse(s);//JSON string
                this.setState({
                    pairedDs: this.state.pairedDs.cloneWithRows(ss.paired || []),
                    foundDs: this.state.foundDs.cloneWithRows(ss.found || []),
                    loading: false
                }, ()=> {
                    this.paired = ss.paired || [];
                    this.found = ss.found || [];
                });
            }, (er)=> {
                this.setState({
                    loading: false
                })
                alert('error' + JSON.stringify(er));
            });
connect ==> async function, connects the specified device, if not bound, bound dailog prompts.
    BluetoothManager.connect(rowData.address) // the device address scanned.
     .then((s)=>{
       this.setState({
        loading:false,
        boundAddress:rowData.address
    })
    },(e)=>{
       this.setState({
         loading:false
     })
       alert(e);
    })
unpair ==> async function, disconnects and unpairs the specified devices
     BluetoothManager.connect(rowData.address)
     .then((s)=>{
        //success here
     },
     (err)=>{
        //error here
     })
Events of BluetoothManager module
Name/KEY	DESCRIPTION
EVENT_DEVICE_ALREADY_PAIRED	Emits the devices array already paired
EVENT_DEVICE_DISCOVER_DONE	Emits when the scan done
EVENT_DEVICE_FOUND	Emits when device found during scan
EVENT_CONNECTION_LOST	Emits when device connection lost
EVENT_UNABLE_CONNECT	Emits when error occurs while trying to connect device
EVENT_CONNECTED	Emits when device connected
EVENT_BLUETOOTH_NOT_SUPPORT	Emits when device not support bluetooth(android only)
BluetoothTscPrinter
The printer for label printing.

printLabel ==> async function that performs the label print action.
BluetoothTscPrinter.printLabel(options)
.then(()=>{
    //success
},
(err)=>{
    //error
})
Options of printLabel( ) function: (JSON object)
width
label width , the real size of the label, measured by mm usually.
height
label height, the real size of the label, measured by mm usually.
direction
the printing direction, constants of BluetoothTscPrinter.DIRECTION, values BluetoothTscPrinter.DIRECTION.FORWARD/BluetoothTscPrinter.DIRECTION.BACKWARD (0/1)
gap
the gap between 2 labels, measured by mm usually.
reference
the "zero" position of the label, values [x,y], default [0,0]
tear
switch of the paper cut, constants of BluetoothTscPrinter.TEAR, values ON/OFF (string 'ON','OFF')
sound
switch of the bee sound, values 0/1
text
the collection of texts to print, contains following fields as the configuration:
    * text
        the text string,
    * x
        the text print start position-x
    * y
        the text print start position-y
    * fonttype
        the font type of the text, constanst of BluetoothTscPrinter.FONTTYPE,refereces as table:
            | CONSTANTS | VALUE   |
            |---|---|
            |FONT_1| "1"|
            |FONT_2| "2"|
            |FONT_3| "3"|
            |FONT_4| "4"|
            |FONT_5| "5"|
            |FONT_6| "6"|
            |FONT_7| "7"|
            |FONT_8|"8"|
            |SIMPLIFIED_CHINESE| "TSS24.BF2"|
            |TRADITIONAL_CHINESE| "TST24.BF2"|
            |KOREAN| "K"|
    * rotation
        the rotation of the text, constants of the BluetoothTscPrinter.ROTATION, referces as table:
               | CONSTANTS | VALUE   |
               |---|---|
               |ROTATION_0| 0|
               |ROTATION_90| 90|
               |ROTATION_180| 180|
               |ROTATION_270| 270|
    * xscal
        the scal in x,
    * yscal
        the scal in y, xscal/yscal is the constants of the BluetoothTscPrinter.FONTMUL, referces as table:
         | CONSTANTS | VALUE   |
         |---|---|
         |MUL_1| 1|
         |MUL_2| 2|
         |MUL_3| 3|
         |MUL_4| 4|
         |MUL_5| 5|
         |MUL_6| 6|
         |MUL_7| 7|
         |MUL_8| 8|
         |MUL_9| 9|
         |MUL_10: 10|
qrcode
the collection of qrcodes to print, contains following fields as the configuration:
    * code
        the qrcode content string.
    * x
        the print start position at x
    * y
        the print start position at y
    * level
        the error correction level, constants of BluetoothTscPrinter.EEC, referces as tables:
        | CONSTANTS | VALUE   |
        |---|---|
        |LEVEL_L|"L"|
        |LEVEL_M| "M"|
        |LEVEL_Q| "Q"|
        |LEVEL_H| "H"|
    * width
        the qrcode size (width X width),since the qrcode are square normally, so we just config the width.

    * rotation
        rotation. the same as text object.
barcode
the collection of barcode to print, contains following fields as configuration
  * x
    the print start position of x,
  * y
    the print start position of y,
  * type
    the barcode type, constants of BluetoothTscPrinter, definition as table:
    | CONSTRANTS | VALUE |
    |---|---|
    | CODE128 | "128" |
    | CODE128M | "128M" |
    | EAN128 | "EAN128" |
    | ITF25 | "25" |
    | ITF25C | "25C" |
    | CODE39 | "39" |
    | CODE39C | "39C" |
    | CODE39S | "39S" |
    | CODE93 | "93" |
    | EAN13 | "EAN13" |
    | EAN13_2 | "EAN13+2" |
    | EAN13_5 | "EAN13+5" |
    | EAN8 | "EAN8" |
    | EAN8_2 | "EAN8+2" |
    | EAN8_5 | "EAN8+5" |
    | CODABAR | "CODA" |
    | POST | "POST" |
    | UPCA | "EAN13" |
    | UPCA_2 | "EAN13+2" |
    | UPCA_5 | "EAN13+5" |
    | UPCE | "EAN13" |
    | UPCE_2 | "EAN13+2" |
    | UPCE_5 | "EAN13+5" |
    | CPOST | "CPOST" |
    | MSI | "MSI" |
    | MSIC | "MSIC" |
    | PLESSEY | "PLESSEY" |
    | ITF14 | "ITF14" |
    | EAN14 | "EAN14" |

 * height
  the height of the barcode.
 * readable
  the human readable factor, 0-not readable, 1-readable.
 * rotation
  rotation, the same as text.
 * code
  the code to generate and print, should follow the restriction of the code type using.
 * wide
 the wide bar lines width (dot)
 * narrow
 the narrow bar line width (dot)
image
the collection of the image to print.
 * x
 the print start position x.
 * y
 the print start position y.
 * mode
 the bitmap mode of print, constants of BluetoothTscPrinter.BITMAP_MODE, valuse OVERWRITE(0),OR(1),XOR(2).
 * width
 the width of the image to print. (height will be calculated by image ratio)
 * image
 the base64 encoded image data(without schema)
demo of printLabel() options
let options = {
   width: 40,
   height: 30,
   gap: 20,
   direction: BluetoothTscPrinter.DIRECTION.FORWARD,
   reference: [0, 0],
   tear: BluetoothTscPrinter.TEAR.ON,
   sound: 0,
   text: [{
       text: 'I am a testing txt',
       x: 20,
       y: 0,
       fonttype: BluetoothTscPrinter.FONTTYPE.SIMPLIFIED_CHINESE,
       rotation: BluetoothTscPrinter.ROTATION.ROTATION_0,
       xscal:BluetoothTscPrinter.FONTMUL.MUL_1,
       yscal: BluetoothTscPrinter.FONTMUL.MUL_1
   },{
       text: '你在说什么呢?',
       x: 20,
       y: 50,
       fonttype: BluetoothTscPrinter.FONTTYPE.SIMPLIFIED_CHINESE,
       rotation: BluetoothTscPrinter.ROTATION.ROTATION_0,
       xscal:BluetoothTscPrinter.FONTMUL.MUL_1,
       yscal: BluetoothTscPrinter.FONTMUL.MUL_1
   }],
   qrcode: [{x: 20, y: 96, level: BluetoothTscPrinter.EEC.LEVEL_L, width: 3, rotation: BluetoothTscPrinter.ROTATION.ROTATION_0, code: 'show me the money'}],
   barcode: [{x: 120, y:96, type: BluetoothTscPrinter.BARCODETYPE.CODE128, height: 40, readable: 1, rotation: BluetoothTscPrinter.ROTATION.ROTATION_0, code: '1234567890'}],
   image: [{x: 160, y: 160, mode: BluetoothTscPrinter.BITMAP_MODE.OVERWRITE,width: 60,image: base64Image}]
}
BluetoothEscposPrinter
the printer for receipt printing, following ESC/POS command.

printerInit()
init the printer.

printAndFeed(int feed)
printer the buffer data and feed (feed lines).

printerLeftSpace(int sp)
set the printer left spaces.

printerLineSpace(int sp)
set the spaces between lines.

printerUnderLine(int line)
set the underline of the text, @param line -- 0-off,1-on,2-deeper

printerAlign(int align)
set the printer alignment, constansts: BluetoothEscposPrinter.ALIGN.LEFT/BluetoothEscposPrinter.ALIGN.CENTER/BluetoothEscposPrinter.ALIGN.RIGHT. Does not work on printPic() method.

printText(String text, ReadableMap options)
print text, options as following:

encoding => text encoding,default GBK.
codepage => codepage using, default 0.
widthtimes => text font mul times in width, default 0.
heigthTimes => text font mul times in height, default 0.
fonttype => text font type, default 0.
printColumn(ReadableArray columnWidths,ReadableArray columnAligns,ReadableArray columnTexts,ReadableMap options)
print texts in column, Parameters as following:

columnWidths => int arrays, configs the width of each column, calculate by english character length. ex:the width of "abcdef" is 5 ,the width of "中文" is 4.
columnAligns => arrays, alignment of each column, values is the same of printerAlign().
columnTexts => arrays, the texts of each colunm to print.
options => text print config options, the same of printText() options.
setWidth(int width)
sets the width of the printer.

printPic(String base64encodeStr,ReadableMap options)
prints the image which is encoded by base64, without schema.

options: contains the params that may use in printing pic: "width": the pic width, basic on devices width(dots,58mm-384); "left": the left padding of the pic for the printing position adjustment.
setfTest()
prints the self test.

rotate()
sets the rotation of the line.

setBlob(int weight)
sets blob of the line.

printQRCode(String content, int size, int correctionLevel)
prints the qrcode.

printBarCode(String str,int nType, int nWidthX, int nHeight, int nHriFontType, int nHriFontPosition)
prints the barcode.

Demos of printing a receipt
await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.CENTER);
await BluetoothEscposPrinter.setBlob(0);
await  BluetoothEscposPrinter.printText("广州俊烨\n\r",{
  encoding:'GBK',
  codepage:0,
  widthtimes:3,
  heigthtimes:3,
  fonttype:1
});
await BluetoothEscposPrinter.setBlob(0);
await  BluetoothEscposPrinter.printText("销售单\n\r",{
  encoding:'GBK',
  codepage:0,
  widthtimes:0,
  heigthtimes:0,
  fonttype:1
});
await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.LEFT);
await  BluetoothEscposPrinter.printText("客户：零售客户\n\r",{});
await  BluetoothEscposPrinter.printText("单号：xsd201909210000001\n\r",{});
await  BluetoothEscposPrinter.printText("日期："+(dateFormat(new Date(), "yyyy-mm-dd h:MM:ss"))+"\n\r",{});
await  BluetoothEscposPrinter.printText("销售员：18664896621\n\r",{});
await  BluetoothEscposPrinter.printText("--------------------------------\n\r",{});
let columnWidths = [12,6,6,8];
await BluetoothEscposPrinter.printColumn(columnWidths,
  [BluetoothEscposPrinter.ALIGN.LEFT,BluetoothEscposPrinter.ALIGN.CENTER,BluetoothEscposPrinter.ALIGN.CENTER,BluetoothEscposPrinter.ALIGN.RIGHT],
  ["商品",'数量','单价','金额'],{});
await BluetoothEscposPrinter.printColumn(columnWidths,
  [BluetoothEscposPrinter.ALIGN.LEFT,BluetoothEscposPrinter.ALIGN.LEFT,BluetoothEscposPrinter.ALIGN.CENTER,BluetoothEscposPrinter.ALIGN.RIGHT],
  ["React-Native定制开发我是比较长的位置你稍微看看是不是这样?",'1','32000','32000'],{});
    await  BluetoothEscposPrinter.printText("\n\r",{});
  await BluetoothEscposPrinter.printColumn(columnWidths,
  [BluetoothEscposPrinter.ALIGN.LEFT,BluetoothEscposPrinter.ALIGN.LEFT,BluetoothEscposPrinter.ALIGN.CENTER,BluetoothEscposPrinter.ALIGN.RIGHT],
  ["React-Native定制开发我是比较长的位置你稍微看看是不是这样?",'1','32000','32000'],{});
await  BluetoothEscposPrinter.printText("\n\r",{});
await  BluetoothEscposPrinter.printText("--------------------------------\n\r",{});
await BluetoothEscposPrinter.printColumn([12,8,12],
  [BluetoothEscposPrinter.ALIGN.LEFT,BluetoothEscposPrinter.ALIGN.LEFT,BluetoothEscposPrinter.ALIGN.RIGHT],
  ["合计",'2','64000'],{});
await  BluetoothEscposPrinter.printText("\n\r",{});
await  BluetoothEscposPrinter.printText("折扣率：100%\n\r",{});
await  BluetoothEscposPrinter.printText("折扣后应收：64000.00\n\r",{});
await  BluetoothEscposPrinter.printText("会员卡支付：0.00\n\r",{});
await  BluetoothEscposPrinter.printText("积分抵扣：0.00\n\r",{});
await  BluetoothEscposPrinter.printText("支付金额：64000.00\n\r",{});
await  BluetoothEscposPrinter.printText("结算账户：现金账户\n\r",{});
await  BluetoothEscposPrinter.printText("备注：无\n\r",{});
await  BluetoothEscposPrinter.printText("快递单号：无\n\r",{});
await  BluetoothEscposPrinter.printText("打印时间："+(dateFormat(new Date(), "yyyy-mm-dd h:MM:ss"))+"\n\r",{});
await  BluetoothEscposPrinter.printText("--------------------------------\n\r",{});
await  BluetoothEscposPrinter.printText("电话：\n\r",{});
await  BluetoothEscposPrinter.printText("地址:\n\r\n\r",{});
await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.CENTER);
await  BluetoothEscposPrinter.printText("欢迎下次光临\n\r\n\r\n\r",{});
await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.LEFT);
Demo for opening the drawer
BluetoothEscposPrinter.opendDrawer(0, 250, 250);

================
File: docs/react-native-community-datetimepicker.md
================
# React Native DateTimePicker

This repository was moved out of the react native community GH organization, in accordance to [this proposal](https://github.com/react-native-community/discussions-and-proposals/issues/463). The module is still published on npm under the old namespace (as documented) but will be published under a new namespace at some point, with a major version bump.

[![CircleCI Status](https://circleci.com/gh/react-native-community/react-native-datetimepicker.svg?style=shield)](https://circleci.com/gh/react-native-community/react-native-datetimepicker) [![Supports Android and iOS](https://img.shields.io/badge/platforms-android%20|%20ios%20|%20windows-lightgrey.svg)](https://github.com/react-native-community/react-native-datetimepicker) [![MIT License](https://img.shields.io/npm/l/@react-native-community/datetimepicker.svg)](https://github.com/react-native-community/react-native-datetimepicker/blob/master/LICENSE) [![Lean Core Badge](https://img.shields.io/badge/Lean%20Core-Extracted-brightgreen.svg)](https://github.com/facebook/react-native/issues/23313)

React Native date & time picker component for iOS, Android and Windows (please note Windows is not actively maintained).

## Screenshots
<details>
<summary>Expand for screenshots</summary>

| iOS Date | iOS Time | iOS DateTime | iOS Countdown |
|---|---|---|---|
| ![ios date picker](https://user-images.githubusercontent.com/716980/159198891-4713f110-f11c-4115-841e-461150161e1d.png) | ![ios time picker](https://user-images.githubusercontent.com/716980/159198900-80f3f110-f11c-4115-841e-461150161e1d.png) | ![ios datetime picker](https://user-images.githubusercontent.com/716980/159198905-c1f3f110-f11c-4115-841e-461150161e1d.png) | ![ios countdown picker](https://user-images.githubusercontent.com/716980/159198910-05f3f110-f11c-4115-841e-461150161e1d.png) |

| Android Date | Android Time |
|---|---|
| ![android date picker](https://user-images.githubusercontent.com/716980/159198915-4713f110-f11c-4115-841e-461150161e1d.png) | ![android time picker](https://user-images.githubusercontent.com/716980/159198920-80f3f110-f11c-4115-841e-461150161e1d.png) |

| Windows Date | Windows Time |
|---|---|
| ![windows date picker](https://user-images.githubusercontent.com/716980/159198925-c1f3f110-f11c-4115-841e-461150161e1d.png) | ![windows time picker](https://user-images.githubusercontent.com/716980/159198930-05f3f110-f11c-4115-841e-461150161e1d.png) |

</details>

## Table of contents

- [React Native DateTimePicker](#react-native-datetimepicker)
  - [Screenshots](#screenshots)
  - [Table of contents](#table-of-contents)
  - [Requirements](#requirements)
  - [Expo users notice](#expo-users-notice)
  - [Getting started](#getting-started)
    - [RN \>= 0.60](#rn--060)
  - [React Native Support](#react-native-support)
  - [Usage](#usage)
  - [Localization note](#localization-note)
  - [Android imperative api](#android-imperative-api)
  - [Android styling](#android-styling)
  - [Component props / params of the Android imperative api](#component-props--params-of-the-android-imperative-api)
    - [mode (optional)](#mode-optional)
    - [display (optional)](#display-optional)
    - [design (optional, Android only)](#design-optional-android-only)
    - [onChange (optional)](#onchange-optional)
    - [value (required)](#value-required)
    - [maximumDate (optional)](#maximumdate-optional)
    - [minimumDate (optional)](#minimumdate-optional)
    - [timeZoneName (optional, iOS and Android only)](#timezonename-optional-ios-and-android-only)
    - [timeZoneOffsetInMinutes (optional, iOS and Android only)](#timezoneoffsetinminutes-optional-ios-and-android-only)
    - [timeZoneOffsetInSeconds (optional, Windows only)](#timezoneoffsetinseconds-optional-windows-only)
    - [dayOfWeekFormat (optional, Windows only)](#dayofweekformat-optional-windows-only)
    - [dateFormat (optional, Windows only)](#dateformat-optional-windows-only)
    - [firstDayOfWeek (optional, Android and Windows only)](#firstdayofweek-optional-android-and-windows-only)
    - [textColor (optional, iOS only)](#textcolor-optional-ios-only)
    - [accentColor (optional, iOS only)](#accentcolor-optional-ios-only)
    - [themeVariant (optional, iOS only)](#themevariant-optional-ios-only)
    - [locale (optional, iOS only)](#locale-optional-ios-only)
    - [is24Hour (optional, Windows and Android only)](#is24hour-optional-windows-and-android-only)
    - [initialInputMode (optional, Android only)](#initialinputmode-optional-android-only)
    - [title (optional, Android only)](#title-optional-android-only)
    - [fullscreen (optional, Android only)](#fullscreen-optional-android-only)
    - [positiveButton (optional, Android only)](#positivebutton-optional-android-only)
    - [neutralButton (optional, Android only)](#neutralbutton-optional-android-only)
    - [negativeButton (optional, Android only)](#negativebutton-optional-android-only)
    - [positiveButtonLabel (optional, Android only, deprecated)](#positivebuttonlabel-optional-android-only-deprecated)
    - [negativeButtonLabel (optional, Android only, deprecated)](#negativebuttonlabel-optional-android-only-deprecated)
    - [neutralButtonLabel (optional, Android only, deprecated)](#neutralbuttonlabel-optional-android-only-deprecated)
    - [minuteInterval (optional)](#minuteinterval-optional)
    - [style (optional, iOS only)](#style-optional-ios-only)
    - [disabled (optional, iOS only)](#disabled-optional-ios-only)
    - [testID (optional)](#testid-optional)
    - [View Props (optional, iOS only)](#view-props-optional-ios-only)
    - [onError (optional, Android only)](#onerror-optional-android-only)
  - [Testing with Jest](#testing-with-jest)

## Requirements

Only Android API level >=21 (Android 5), iOS >= 11 are supported.
Tested with Xcode 14.0 and RN 0.72.7. Other configurations are very likely to work as well but have not been tested.
The module supports the new React Native architecture (Fabric rendering of iOS components, and turbomodules on Android). If you are using the new architecture, you will need to use React Native 0.71.4 or higher.

## Expo users notice

This module is part of Expo Managed Workflow - see [docs](https://docs.expo.dev/versions/latest/sdk/date-time-picker/). However, Expo SDK in the Managed Workflow may not contain the latest version of the module and therefore, the newest features and bugfixes may not be available in Expo Managed Workflow. If you use the Managed Workflow, use the command `expo install @react-native-community/datetimepicker` (not `yarn` or `npm`) to install this module - Expo will automatically install the latest version compatible with your Expo SDK (which may not be the latest version of the module available).

If you're using a Dev Client, rebuild the Dev Client after installing the dependencies.

If you're using the `expo prebuild` command and building your native app projects (e.g. with EAS Build or locally), you can use the latest version of the module.

## Getting started

```bash
npm install @react-native-community/datetimepicker --save
```

or

```bash
yarn add @react-native-community/datetimepicker
```

Autolinking is not yet implemented on Windows, so [manual installation](#manual-installation) is needed.

### RN >= 0.60

If you are using RN >= 0.60, only run `npx pod-install`. Then rebuild your project.

## React Native Support

Check the react-native version support table below to find the corresponding datetimepicker version to meet support requirements. Maintenance is only provided for last 3 stable react-native versions.

| react-native version | version |
| -------------------- | ------- |
| 0.73.0+              | 7.6.3+  |
| <=0.72.0             | <=7.6.2 |
| 0.70.0+              | 7.0.1+  |
| <0.70.0              | <=7.0.0 |

## Usage

```javascript
import DateTimePicker from '@react-native-community/datetimepicker';
```

<details>
<summary>Expand for examples</summary>

```javascript
import React, {useState} from 'react';
import {View, Button, Platform} from 'react-native';
import DateTimePicker from '@react-native-community/datetimepicker';

export const App = () => {
  const [date, setDate] = useState(new Date(1598051730000));
  const [mode, setMode] = useState('date');
  const [show, setShow] = useState(false);

  const onChange = (event, selectedDate) => {
    const currentDate = selectedDate || date;
    setShow(Platform.OS === 'ios');
    setDate(currentDate);
  };

  const showMode = (currentMode) => {
    setShow(true);
    setMode(currentMode);
  };

  const showDatepicker = () => {
    showMode('date');
  };

  const showTimepicker = () => {
    showMode('time');
  };

  return (
    <View>
      <View>
        <Button onPress={showDatepicker} title="Show date picker!" />
      </View>
      <View>
        <Button onPress={showTimepicker} title="Show time picker!" />
      </View>
      {show && (
        <DateTimePicker
          testID="dateTimePicker"
          value={date}
          mode={mode}
          is24Hour={true}
          display="default"
          onChange={onChange}
        />
      )}
    </View>
  );
};
```

</details>

## Localization note

By localization, we refer to the language (names of months and days), as well as order in which date can be presented in a picker (month/day vs. day/month) and 12 / 24 hour-format.

On Android, the picker will be controlled by the system locale. If you wish to change it, see instructions [here](https://developer.android.com/guide/topics/resources/localization).

On iOS, use XCode, as documented [here](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/LocalizingYourApp/LocalizingYourApp.html) to inform the OS about the locales your application supports. iOS will automatically display the correctly localized DateTimePicker as long as the target language is contained in `project.pbxproj`.

If you use a library like `i18next` or `react-localize-redux` to manage your translations, it is sufficient to add your target languages as described in the Apple Documentation - but you are not required to add any localization keys (like, for example, the days of the week). iOS will automatically display the correct localized strings as long as the target language is contained in `project.pbxproj`.

For testing your localization setup, refer [here](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/TestingYourInternationalApp/TestingYourInternationalApp.html).

There is also the iOS-only `locale` prop that can be used to force locale in some cases but its usage is discouraged due to not working robustly in all picker modes (note the mixed month and day names). To the best of our knowledge, it works reliably in the `spinner` mode.

For Expo, follow the [localization docs](https://docs.expo.dev/guides/localization/).

## Android imperative api

On Android, you have a choice between using the component API (regular React component) or an imperative api (think of something like `ReactNative.alert()`).

While the component API has the benefit of writing the same code on all platforms, for start we recommend using the imperative API on Android.

The `params` is an object with the same properties as the component props documented in the next paragraph. (This is also because the component api internally uses the imperative one.)

```javascript
import { DateTimePickerAndroid } from '@react-native-community/datetimepicker';

DateTimePickerAndroid.open(params: AndroidNativeProps)
DateTimePickerAndroid.dismiss(mode: AndroidNativeProps['mode'])
```

The reason we recommend the imperative API is: on Android, the date/time picker opens in a dialog, similar to `ReactNative.alert()` from core react native. The imperative api models this behavior better than the declarative component api. While the component approach is perfectly functional, based on the issue tracker history, it appears to be more prone to introducing bugs.

## Android styling

If you'd like to use the Material pickers, your app theme will need to inherit from `Theme.Material3.DayNight.NoActionBar` in `styles.xml`.

Styling of the dialogs on Android can be easily customized by using the provided config plugin, provided that you use a Expo development build. The plugin allows you to configure color properties that cannot be set at runtime and requires building a new app binary to take effect.

Refer to this documentation for more information: [android-styling.md](https://github.com/react-native-community/react-native-datetimepicker/blob/master/docs/android-styling.md).

## Component props / params of the Android imperative api

Please note that this library currently exposes functionality from `UIDatePicker` on iOS and `DatePickerDialog` + `TimePickerDialog` on Android, and `CalendarDatePicker` + `TimePicker` on Windows.

These native classes offer only limited configuration, while there are dozens of possible options you as a developer may need. It follows that if your requirement is not supported by the backing native views, this library will not be able to implement your requirement. When you open an issue with a feature request, please document if (or how) the feature can be implemented using the aforementioned native views. If the native views do not support what you need, such feature requests will be closed as not actionable.

### mode (optional)

Defines the type of the picker.

List of possible values:

- `"date"` (default for iOS and Android and Windows)
- `"time"`
- `"datetime"` (iOS only)
- `"countdown"` (iOS only)

```jsx
<RNDateTimePicker mode="time" />
```

### display (optional)

Defines the visual display of the picker. The default value is `"default"`.

List of possible values for Android

- `"default"` - Recommended. Show a default date picker (spinner/calendar/clock) based on mode.
- `"spinner"`
- `"calendar"` (only for `date` mode)
- `"clock"` (only for `time` mode)

List of possible values for iOS (maps to `preferredDatePickerStyle`)

- `"default"` - Automatically pick the best style available for the current platform & mode.
- `"spinner"` - the usual pre-iOS 14 appearance with a wheel from which you choose values
- `"compact"` - Affects only iOS 14 and later. Will fall back to `"spinner"` if not supported.
- `"inline"` - Affects only iOS 14 and later. Will fall back to `"spinner"` if not supported.

```jsx
<RNDateTimePicker display="spinner" />
```

### design (optional, Android only)

Defines if the picker should use Material 3 components or the default picker. The default value is `"default"`.

List of possible values

- `"default"`
- `"material"`

```jsx
<RNDateTimePicker design="material" />
```

### onChange (optional)

Date change handler.

This is called when the user changes the date or time in the UI. It receives the event and the date as parameters. It is also called when user dismisses the picker, which you can detect by checking the `event.type` property. The values can be: `'set' | 'dismissed' | 'neutralButtonPressed'`. (`neutralButtonPressed` is only available on Android).

The `utcOffset` field is only available on Android and iOS. It is the offset in minutes between the selected date and UTC time.

```javascript
const setDate = (event: DateTimePickerEvent, date: Date) => {
  const {
    type,
    nativeEvent: {timestamp, utcOffset},
  } = event;
};

<RNDateTimePicker onChange={this.setDate} />;
```

### value (required)

Defines the date or time value used in the component.

```jsx
<RNDateTimePicker value={new Date()} />
```

### maximumDate (optional)

Defines the maximum date that can be selected. Note that on Android, this only works for `date` mode because `TimePicker` does not support this.

```jsx
<RNDateTimePicker maximumDate={new Date(2030, 10, 20)} />
```

### minimumDate (optional)

Defines the minimum date that can be selected. Note that on Android, this only works for `date` mode because `TimePicker` does not support this.

```jsx
<RNDateTimePicker minimumDate={new Date(1950, 0, 1)} />
```

### timeZoneName (optional, iOS and Android only)

Allows changing of the time zone of the date picker. By default, it uses the device's time zone. Use the time zone name from the IANA (TZDB) database name in https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

```jsx
<RNDateTimePicker timeZoneName={'Europe/Prague'} />
```

### timeZoneOffsetInMinutes (optional, iOS and Android only)

Allows changing of the time zone of the date picker. By default, it uses the device's time zone. We strongly recommend using `timeZoneName` prop instead; this prop has known issues in the android implementation (eg. [#528](https://github.com/react-native-community/react-native-datetimepicker/issues/528)).

This prop will be removed in a future release.

```jsx
// GMT+1
<RNDateTimePicker timeZoneOffsetInMinutes={60} />
```

### timeZoneOffsetInSeconds (optional, Windows only)

Allows changing of the time zone of the date picker. By default, it uses the device's time zone.

```jsx
// UTC+1
<RNDateTimePicker timeZoneOffsetInSeconds={3600} />
```

### dayOfWeekFormat (optional, Windows only)

Sets the display format for the day of the week headers. Reference: https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.controls.calendarview.dayofweekformat?view=winrt-18362#remarks

```jsx
<RNDateTimePicker dayOfWeekFormat={'{dayofweek.abbreviated(2)}'} />
```

### dateFormat (optional, Windows only)

Sets the display format for the date value in the picker's text box. Reference: https://docs.microsoft.com/en-us/uwp/api/windows.globalization.datetimeformatting.datetimeformatter?view=winrt-18362#examples

```jsx
<RNDateTimePicker dateFormat="dayofweek day month" />
```

### firstDayOfWeek (optional, Android and Windows only)

Indicates which day is shown as the first day of the week.

```jsx
<RNDateTimePicker firstDayOfWeek={DAY_OF_WEEK.Wednesday} />
// The native parameter type is an enum defined in defined https://docs.microsoft.com/en-us/uwp/api/windows.globalization.dayofweek?view=winrt-18362 - meaning an integer needs to passed here (DAY_OF_WEEK).
```

### textColor (optional, iOS only)

Allows changing of the textColor of the date picker. Has effect only when `display` is `"spinner"`.

```jsx
<RNDateTimePicker textColor="red" />
```

### accentColor (optional, iOS only)

Allows changing the `accentColor` (`tintColor`) of the date picker. Has no effect when `display` is `"spinner"`.

### themeVariant (optional, iOS only)

Allows overriding system theme variant (dark or light mode) used by the date picker. However, we recommend that you instead control the theme of the whole application using [react-native-theme-control](https://github.com/vonovak/react-native-theme-control).

⚠️ Has effect only on iOS 14 and later. On iOS 13 & less, use `textColor` to make the picker dark-theme compatible

List of possible values:

- `"light"`
- `"dark"`

```jsx
<RNDateTimePicker themeVariant="light" />
```

### locale (optional, iOS only)

Allows changing the locale of the component. This affects the displayed text and the date / time formatting. By default, the device's locale is used. Please note using this prop is discouraged due to not working reliably in all picker modes. Prefer localization as documented in [Localization note](#localization-note).

```jsx
<RNDateTimePicker locale="es-ES" />
```

### is24Hour (optional, Windows and Android only)

Allows changing of the time picker to a 24-hour format. By default, this value is decided automatically based on the locale and other preferences.

```jsx
<RNDateTimePicker is24Hour={true} />
```

### initialInputMode (optional, Android only)

⚠️ Has effect only when `design` is `"material"`. Allows setting the initial input mode of the picker.

List of possible values:

- `"default"` - Recommended. Date pickers will show the calendar view by default, and time pickers will show the clock view by default.
- `"keyboard"` - Both pickers will show an input where the user can type the date or time.

```jsx
<RNDateTimePicker initialInputMode="default" />
```

### title (optional, Android only)

⚠️ Has effect only when `design` is `"material"`. Allows setting the title of the dialog for the pickers.

```jsx
<RNDateTimePicker title="Choose anniversary" />
```

### fullscreen (optional, Android only)

⚠️ Has effect only when `design` is `"material"`. Allows setting the date picker dialog to be fullscreen.

```jsx
<RNDateTimePicker fullscreen={true} />
```

### positiveButton (optional, Android only)

Set the positive button label and text color.

```jsx
<RNDateTimePicker positiveButton={{label: 'OK', textColor: 'green'}} />
```

### neutralButton (optional, Android only)

Allows displaying neutral button on picker dialog. Pressing button can be observed in `onChange` handler as `event.type === 'neutralButtonPressed'`

```jsx
<RNDateTimePicker neutralButton={{label: 'Clear', textColor: 'grey'}} />
```

### negativeButton (optional, Android only)

Set the negative button label and text color.

```jsx
<RNDateTimePicker negativeButton={{label: 'Cancel', textColor: 'red'}} />
```

### positiveButtonLabel (optional, Android only, deprecated)

Changes the label of the positive button.

```jsx
<RNDateTimePicker positiveButtonLabel="OK!" />
```

### negativeButtonLabel (optional, Android only, deprecated)

Changes the label of the negative button.

```jsx
<RNDateTimePicker negativeButtonLabel="Negative" />
```

### neutralButtonLabel (optional, Android only, deprecated)

Allows displaying neutral button on picker dialog. Pressing button can be observed in `onChange` handler as `event.type === 'neutralButtonPressed'`

```jsx
<RNDateTimePicker neutralButtonLabel="clear" />
```

### minuteInterval (optional)

The interval at which minutes can be selected. Possible values are: `1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30`

On Windows, this can be any number between 0-59.

on iOS, this in only supported when `display="spinner"`

```jsx
<RNDateTimePicker minuteInterval={10} />
```

### style (optional, iOS only)

Sets style directly on picker component. By default, the picker dimensions are determined based on the props.

Please note that by default, picker's text color is controlled by the application theme (light / dark mode). In dark mode, text is white and in light mode, text is black. If you want to control the application theme, we recommend using [react-native-theme-control](https://github.com/vonovak/react-native-theme-control).

This means that e.g. if the device has dark mode turned on, and your screen background color is white, you will not see the picker. Please use the `Appearance` api to adjust the picker's background color so that it is visible, as we do in the example App. Alternatively, use the `themeVariant` prop.

```jsx
<RNDateTimePicker style={{flex: 1}} />
```

### disabled (optional, iOS only)

If true, the user won't be able to interact with the view.

### testID (optional)

Usually used by app automation frameworks. Fully supported on iOS. On Android, only supported for `mode="date"`.

```jsx
<RNDateTimePicker testID="datePicker" />
```

### View Props (optional, iOS only)

On iOS, you can pass any `View` props to the component. Given that the underlying component is a native view, not all of them are guaranteed to be supported, but `testID` and `onLayout` are known to work.

### onError (optional, Android only)

Callback that is called when an error occurs inside the date picker native code (such as null activity).

## Testing with Jest

================
File: docs/react-native-paper.md
================
# Documentación de React Native Paper

## Introducción

React Native Paper es una colección de componentes personalizables y listos para producción para React Native, siguiendo las directrices de Material Design de Google. Esta biblioteca proporciona una amplia gama de componentes UI que facilitan el desarrollo de aplicaciones móviles con una apariencia profesional y consistente tanto en iOS como en Android.

## Componentes

### ActivityIndicator

El componente ActivityIndicator muestra un indicador de carga circular.

#### Uso

```jsx
import * as React from "react";
import { ActivityIndicator } from "react-native-paper";

const MyComponent = () => (
  <ActivityIndicator animating={true} color="#00ff00" />
);
```

#### Propiedades

- **animating**: boolean - Determina si el indicador está animándose.
- **color**: string - Color del indicador.
- **size**: 'small' | 'large' | number - Tamaño del indicador.
- **hidesWhenStopped**: boolean - Oculta el indicador cuando no está animándose.

### Appbar

El componente Appbar muestra información y acciones relacionadas con la pantalla actual.

#### Uso

```jsx
import * as React from "react";
import { Appbar } from "react-native-paper";

const MyComponent = () => (
  <Appbar.Header>
    <Appbar.BackAction onPress={() => {}} />
    <Appbar.Content title="Título" subtitle="Subtítulo" />
    <Appbar.Action icon="magnify" onPress={() => {}} />
    <Appbar.Action icon="dots-vertical" onPress={() => {}} />
  </Appbar.Header>
);
```

#### Subcomponentes

- **Appbar.Header**: Contenedor principal para la barra de aplicaciones.
- **Appbar.BackAction**: Botón de retroceso.
- **Appbar.Content**: Contenido principal (título y subtítulo).
- **Appbar.Action**: Botón de acción con icono.

#### Propiedades principales

- **dark**: boolean - Determina si la barra de aplicaciones utiliza el tema oscuro.
- **statusBarHeight**: number - Altura de la barra de estado.
- **elevated**: boolean - Determina si la barra de aplicaciones tiene elevación.
- **style**: object - Estilo personalizado para la barra de aplicaciones.

### Avatar

El componente Avatar muestra una imagen de perfil, iniciales o icono.

#### Uso

```jsx
import * as React from "react";
import { Avatar } from "react-native-paper";

const MyComponent = () => (
  <>
    <Avatar.Icon size={24} icon="folder" />
    <Avatar.Image size={24} source={require("../assets/avatar.png")} />
    <Avatar.Text size={24} label="XD" />
  </>
);
```

#### Subcomponentes

- **Avatar.Icon**: Avatar con un icono.
- **Avatar.Image**: Avatar con una imagen.
- **Avatar.Text**: Avatar con texto (iniciales).

#### Propiedades principales

- **size**: number - Tamaño del avatar.
- **style**: object - Estilo personalizado para el avatar.
- **icon**: string - Nombre del icono (para Avatar.Icon).
- **source**: object - Fuente de la imagen (para Avatar.Image).
- **label**: string - Texto a mostrar (para Avatar.Text).

### Badge

El componente Badge muestra un pequeño indicador numérico o de estado.

#### Uso

```jsx
import * as React from "react";
import { Badge } from "react-native-paper";

const MyComponent = () => <Badge>3</Badge>;
```

#### Propiedades

- **visible**: boolean - Determina si el badge es visible.
- **size**: number - Tamaño del badge.
- **style**: object - Estilo personalizado para el badge.

### Banner

El componente Banner muestra un mensaje importante y acciones relacionadas.

#### Uso

```jsx
import * as React from "react";
import { Banner } from "react-native-paper";

const MyComponent = () => {
  const [visible, setVisible] = React.useState(true);

  return (
    <Banner
      visible={visible}
      actions={[
        {
          label: "Arreglar ahora",
          onPress: () => setVisible(false),
        },
        {
          label: "Más tarde",
          onPress: () => setVisible(false),
        },
      ]}
      icon={({ size }) => (
        <Image
          source={require("../assets/notification.png")}
          style={{ width: size, height: size }}
        />
      )}
    >
      Hay problemas con tu conexión a internet.
    </Banner>
  );
};
```

#### Propiedades

- **visible**: boolean - Determina si el banner es visible.
- **actions**: Array - Acciones disponibles en el banner.
- **icon**: ({ size }) => React.ReactNode - Icono a mostrar.
- **children**: React.ReactNode - Contenido del banner.

### BottomNavigation

El componente BottomNavigation proporciona navegación entre vistas principales en una aplicación.

#### Uso

```jsx
import * as React from "react";
import { BottomNavigation, Text } from "react-native-paper";

const MusicRoute = () => <Text>Music</Text>;
const AlbumsRoute = () => <Text>Albums</Text>;
const RecentsRoute = () => <Text>Recents</Text>;

const MyComponent = () => {
  const [index, setIndex] = React.useState(0);
  const [routes] = React.useState([
    { key: "music", title: "Music", icon: "music" },
    { key: "albums", title: "Albums", icon: "album" },
    { key: "recents", title: "Recents", icon: "history" },
  ]);

  const renderScene = BottomNavigation.SceneMap({
    music: MusicRoute,
    albums: AlbumsRoute,
    recents: RecentsRoute,
  });

  return (
    <BottomNavigation
      navigationState={{ index, routes }}
      onIndexChange={setIndex}
      renderScene={renderScene}
    />
  );
};
```

#### Propiedades

- **navigationState**: object - Estado de navegación con índice y rutas.
- **onIndexChange**: function - Función llamada cuando cambia el índice.
- **renderScene**: function - Función para renderizar la escena para una ruta.
- **shifting**: boolean - Determina si la navegación utiliza el modo shifting.
- **labeled**: boolean - Determina si se muestran las etiquetas.

### Button

El componente Button permite a los usuarios realizar acciones y tomar decisiones con un solo toque.

#### Uso

```jsx
import * as React from "react";
import { Button } from "react-native-paper";

const MyComponent = () => (
  <>
    <Button
      icon="camera"
      mode="contained"
      onPress={() => console.log("Pressed")}
    >
      Press me
    </Button>
    <Button
      icon="camera"
      mode="outlined"
      onPress={() => console.log("Pressed")}
    >
      Press me
    </Button>
    <Button icon="camera" mode="text" onPress={() => console.log("Pressed")}>
      Press me
    </Button>
  </>
);
```

#### Propiedades

- **mode**: 'text' | 'outlined' | 'contained' - Modo del botón.
- **dark**: boolean - Determina si el botón utiliza el tema oscuro.
- **compact**: boolean - Determina si el botón es compacto.
- **icon**: string - Icono a mostrar.
- **loading**: boolean - Muestra un indicador de carga.
- **disabled**: boolean - Deshabilita el botón.
- **onPress**: function - Función llamada cuando se presiona el botón.
- **style**: object - Estilo personalizado para el botón.

### CardComponent

El componente Card es una hoja de material que sirve como punto de entrada a información más detallada.

#### Uso

```jsx
import * as React from "react";
import { Avatar, Button, Card, Text } from "react-native-paper";

const LeftContent = (props) => <Avatar.Icon {...props} icon="folder" />;

const MyComponent = () => (
  <Card>
    <Card.Title
      title="Card Title"
      subtitle="Card Subtitle"
      left={LeftContent}
    />
    <Card.Content>
      <Text variant="titleLarge">Card title</Text>
      <Text variant="bodyMedium">Card content</Text>
    </Card.Content>
    <Card.Cover source={{ uri: "https://picsum.photos/700" }} />
    <Card.Actions>
      <Button>Cancel</Button>
      <Button>Ok</Button>
    </Card.Actions>
  </Card>
);
```

#### Subcomponentes

- **Card.Title**: Título de la tarjeta.
- **Card.Content**: Contenido de la tarjeta.
- **Card.Cover**: Imagen de portada de la tarjeta.
- **Card.Actions**: Acciones de la tarjeta.

#### Propiedades principales

- **mode**: 'elevated' | 'outlined' | 'contained' - Modo de la tarjeta.
- **elevation**: number - Elevación de la tarjeta.
- **onPress**: function - Función llamada cuando se presiona la tarjeta.
- **style**: object - Estilo personalizado para la tarjeta.

### Checkbox

El componente Checkbox permite la selección de múltiples opciones de un conjunto.

#### Uso

```jsx
import * as React from "react";
import { Checkbox } from "react-native-paper";

const MyComponent = () => {
  const [checked, setChecked] = React.useState(false);

  return (
    <Checkbox
      status={checked ? "checked" : "unchecked"}
      onPress={() => {
        setChecked(!checked);
      }}
    />
  );
};
```

#### Subcomponentes

- **Checkbox.Android**: Checkbox con estilo de Android.
- **Checkbox.IOS**: Checkbox con estilo de iOS.
- **Checkbox.Item**: Checkbox con etiqueta.

#### Propiedades principales

- **status**: 'checked' | 'unchecked' | 'indeterminate' - Estado del checkbox.
- **disabled**: boolean - Deshabilita el checkbox.
- **onPress**: function - Función llamada cuando se presiona el checkbox.
- **color**: string - Color del checkbox cuando está marcado.
- **uncheckedColor**: string - Color del checkbox cuando no está marcado.

### Chip

El componente Chip es un elemento compacto que representa una entrada, atributo o acción.

#### Uso

```jsx
import * as React from "react";
import { Chip } from "react-native-paper";

const MyComponent = () => (
  <Chip icon="information" onPress={() => console.log("Pressed")}>
    Example Chip
  </Chip>
);
```

#### Propiedades

- **mode**: 'flat' | 'outlined' - Modo del chip.
- **selected**: boolean - Determina si el chip está seleccionado.
- **disabled**: boolean - Deshabilita el chip.
- **icon**: string - Icono a mostrar.
- **avatar**: React.ReactNode - Avatar a mostrar.
- **onPress**: function - Función llamada cuando se presiona el chip.
- **onClose**: function - Función llamada cuando se presiona el botón de cierre.
- **style**: object - Estilo personalizado para el chip.

### DataTable

El componente DataTable permite mostrar conjuntos de datos.

#### Uso

```jsx
import * as React from "react";
import { DataTable } from "react-native-paper";

const MyComponent = () => {
  const [page, setPage] = React.useState(0);
  const [numberOfItemsPerPageList] = React.useState([2, 3, 4]);
  const [itemsPerPage, onItemsPerPageChange] = React.useState(
    numberOfItemsPerPageList[0]
  );

  const [items] = React.useState([
    {
      key: 1,
      name: "Cupcake",
      calories: 356,
      fat: 16,
    },
    {
      key: 2,
      name: "Eclair",
      calories: 262,
      fat: 16,
    },
    {
      key: 3,
      name: "Frozen yogurt",
      calories: 159,
      fat: 6,
    },
    {
      key: 4,
      name: "Gingerbread",
      calories: 305,
      fat: 3.7,
    },
  ]);

  return (
    <DataTable>
      <DataTable.Header>
        <DataTable.Title>Dessert</DataTable.Title>
        <DataTable.Title numeric>Calories per piece</DataTable.Title>
        <DataTable.Title numeric>Fat (g)</DataTable.Title>
      </DataTable.Header>

      {items
        .slice(page * itemsPerPage, (page + 1) * itemsPerPage)
        .map((item) => (
          <DataTable.Row key={item.key}>
            <DataTable.Cell>{item.name}</DataTable.Cell>
            <DataTable.Cell numeric>{item.calories}</DataTable.Cell>
            <DataTable.Cell numeric>{item.fat}</DataTable.Cell>
          </DataTable.Row>
        ))}

      <DataTable.Pagination
        page={page}
        numberOfPages={Math.ceil(items.length / itemsPerPage)}
        onPageChange={(page) => setPage(page)}
        itemsPerPage={itemsPerPage}
        onItemsPerPageChange={onItemsPerPageChange}
        numberOfItemsPerPageList={numberOfItemsPerPageList}
        showFastPaginationControls
        selectPageDropdownLabel={"Rows per page"}
      />
    </DataTable>
  );
};
```

#### Subcomponentes

- **DataTable.Header**: Encabezado de la tabla.
- **DataTable.Title**: Título de columna.
- **DataTable.Row**: Fila de la tabla.
- **DataTable.Cell**: Celda de la tabla.
- **DataTable.Pagination**: Paginación de la tabla.

### Dialog

El componente Dialog informa a los usuarios sobre una tarea específica y puede contener información crítica, requerir decisiones o involucrar múltiples tareas.

#### Uso

```jsx
import * as React from "react";
import { View } from "react-native";
import {
  Button,
  Dialog,
  Portal,
  PaperProvider,
  Text,
} from "react-native-paper";

const MyComponent = () => {
  const [visible, setVisible] = React.useState(false);

  const showDialog = () => setVisible(true);
  const hideDialog = () => setVisible(false);

  return (
    <PaperProvider>
      <View>
        <Button onPress={showDialog}>Show Dialog</Button>
        <Portal>
          <Dialog visible={visible} onDismiss={hideDialog}>
            <Dialog.Title>Alert</Dialog.Title>
            <Dialog.Content>
              <Text variant="bodyMedium">This is simple dialog</Text>
            </Dialog.Content>
            <Dialog.Actions>
              <Button onPress={hideDialog}>Done</Button>
            </Dialog.Actions>
          </Dialog>
        </Portal>
      </View>
    </PaperProvider>
  );
};
```

#### Subcomponentes

- **Dialog.Title**: Título del diálogo.
- **Dialog.Content**: Contenido del diálogo.
- **Dialog.Actions**: Acciones del diálogo.
- **Dialog.Icon**: Icono del diálogo.

#### Propiedades principales

- **visible**: boolean - Determina si el diálogo es visible.
- **dismissable**: boolean - Determina si el diálogo se puede cerrar tocando fuera de él.
- **onDismiss**: function - Función llamada cuando se cierra el diálogo.

### Divider

Un Divider es un separador delgado y ligero que agrupa contenido en listas y diseños de página.

#### Uso

```jsx
import * as React from "react";
import { View } from "react-native";
import { Divider, Text } from "react-native-paper";

const MyComponent = () => (
  <View>
    <Text>Lemon</Text>
    <Divider />
    <Text>Mango</Text>
    <Divider />
  </View>
);
```

#### Propiedades

- **leftInset**: boolean - (Renombrado de `inset` en v5.x) Determina si el divisor tiene un margen izquierdo.
- **horizontalInset**: boolean - (Disponible en v5.x con versión de tema 3, valor predeterminado: `false`) Determina si el divisor tiene un margen horizontal en ambos lados.
- **bold**: boolean - (Disponible en v5.x con versión de tema 3, valor predeterminado: `false`) Determina si el divisor debe ser más grueso (negrita).
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el divisor.
- **theme**: ThemeProp - Tema para aplicar al componente.

### Drawer.CollapsedItem

El componente Drawer.CollapsedItem se utiliza para mostrar un elemento de acción con un icono y opcionalmente una etiqueta en un cajón de navegación colapsado.

#### Uso

```jsx
import * as React from "react";
import { Drawer } from "react-native-paper";

const MyComponent = () => (
  <Drawer.CollapsedItem
    focusedIcon="inbox"
    unfocusedIcon="inbox-outline"
    label="Inbox"
  />
);
```

#### Propiedades

- **label**: string - El texto de la etiqueta del elemento.
- **badge**: string | number | boolean - Insignia para mostrar en el icono, puede ser true para mostrar un punto, string o número para mostrar texto.
- **disabled**: boolean - Determina si el elemento está deshabilitado.
- **focusedIcon**: IconSource - Icono a utilizar como icono de destino enfocado, puede ser una cadena, una fuente de imagen o un componente de React.
- **unfocusedIcon**: IconSource - Icono a utilizar como icono de destino no enfocado, puede ser una cadena, una fuente de imagen o un componente de React.
- **active**: boolean - Determina si se debe resaltar el elemento del cajón como activo.
- **onPress**: function - Función a ejecutar al presionar.
- **labelMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente de la etiqueta.
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el botón.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el elemento.
- **theme**: ThemeProp - Tema para aplicar al componente.

### Drawer.Item

El componente Drawer.Item se utiliza para mostrar un elemento de acción con un icono y una etiqueta en un cajón de navegación.

#### Uso

```jsx
import * as React from "react";
import { Drawer } from "react-native-paper";

const MyComponent = () => (
  <Drawer.Item
    style={{ backgroundColor: "#64ffda" }}
    icon="star"
    label="First Item"
  />
);
```

#### Propiedades

- **label**: string (requerido) - El texto de la etiqueta del elemento.
- **icon**: IconSource - Icono a mostrar para el DrawerItem.
- **active**: boolean - Determina si se debe resaltar el elemento del cajón como activo.
- **disabled**: boolean - Determina si el elemento está deshabilitado.
- **onPress**: function - Función a ejecutar al presionar.
- **background**: PressableAndroidRippleConfig - Tipo de fondo para mostrar el feedback (Android).
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el botón.
- **right**: function - Callback que devuelve un elemento React para mostrar en el lado derecho.
- **labelMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente de la etiqueta.
- **rippleColor**: ColorValue - Color del efecto de ondulación.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el elemento.
- **theme**: ThemeProp - Tema para aplicar al componente.

### Drawer.Section

El componente Drawer.Section se utiliza para agrupar contenido dentro de un cajón de navegación.

#### Uso

```jsx
import * as React from "react";
import { Drawer } from "react-native-paper";

const MyComponent = () => {
  const [active, setActive] = React.useState("");

  return (
    <Drawer.Section title="Some title">
      <Drawer.Item
        label="First Item"
        active={active === "first"}
        onPress={() => setActive("first")}
      />
      <Drawer.Item
        label="Second Item"
        active={active === "second"}
        onPress={() => setActive("second")}
      />
    </Drawer.Section>
  );
};
```

#### Propiedades

- **title**: string - Título para mostrar como encabezado de la sección.
- **children**: React.ReactNode (requerido) - Contenido del Drawer.Section.
- **showDivider**: boolean - Determina si se muestra un Divider al final de la sección. True por defecto.
- **titleMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente del título.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para la sección.
- **theme**: ThemeProp - Tema para aplicar al componente.

### FAB (Floating Action Button)

El componente FAB (Floating Action Button) representa la acción principal en una pantalla. Aparece por encima de todo el contenido de la pantalla.

#### Uso

```jsx
import * as React from "react";
import { StyleSheet } from "react-native";
import { FAB } from "react-native-paper";

const MyComponent = () => (
  <FAB icon="plus" style={styles.fab} onPress={() => console.log("Pressed")} />
);

const styles = StyleSheet.create({
  fab: {
    position: "absolute",
    margin: 16,
    right: 0,
    bottom: 0,
  },
});
```

#### Propiedades

- **icon**: IconSource - Icono a mostrar en el FAB. Es opcional solo si label está definido.
- **label**: string - Etiqueta opcional para FAB extendido. Es opcional solo si icon está definido.
- **uppercase**: boolean - Hace que el texto de la etiqueta esté en mayúsculas.
- **background**: PressableAndroidRippleConfig - Tipo de fondo para mostrar el feedback (Android).
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el FAB. Usa label por defecto si está especificado.
- **accessibilityState**: AccessibilityState - Estado de accesibilidad para el FAB.
- **animated**: boolean - Determina si el cambio de icono está animado. Valor por defecto: true.
- **small**: boolean - (Obsoleto en v.5x - use prop size="small") Determina si el FAB es de tamaño mini.
- **color**: string - Color personalizado para el icono y la etiqueta del FAB.
- **rippleColor**: ColorValue - Color del efecto de ondulación.
- **disabled**: boolean - Determina si el FAB está deshabilitado.
- **visible**: boolean - Determina si el FAB está actualmente visible. Valor por defecto: true.
- **loading**: boolean - Determina si se muestra un indicador de carga.
- **onPress**: function - Función a ejecutar al presionar.
- **onLongPress**: function - Función a ejecutar al mantener presionado.
- **delayLongPress**: number - Número de milisegundos que un usuario debe tocar el elemento antes de ejecutar onLongPress.
- **size**: 'small' | 'medium' | 'large' - Tamaño del FAB. Valor por defecto: 'medium'.
  - small - FAB con altura pequeña (40).
  - medium - FAB con altura media predeterminada (56).
  - large - FAB con altura grande (96).
- **customSize**: number - Tamaño personalizado para el FAB. Esta prop tiene prioridad sobre la prop size.
- **mode**: 'flat' | 'elevated' - Modo del FAB. Valor por defecto: 'elevated'.
  - flat - botón sin sombra.
  - elevated - botón con sombra.
- **variant**: 'primary' | 'secondary' | 'tertiary' | 'surface' - Variante de mapeo de colores para combinaciones de colores de contenedor e icono. Valor por defecto: 'primary'.
- **labelMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente de la etiqueta.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el FAB.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **testID**: string - ID de prueba utilizado con fines de testing. Valor por defecto: 'fab'.
- **ref**: React.RefObject<View> - Referencia para el componente.

### AnimatedFAB

El componente AnimatedFAB es un botón de acción flotante animado que se extiende horizontalmente y representa la acción principal en una aplicación.

#### Uso

```jsx
import React from "react";
import {
  StyleProp,
  ViewStyle,
  Animated,
  StyleSheet,
  Platform,
  ScrollView,
  Text,
  SafeAreaView,
  I18nManager,
} from "react-native";
import { AnimatedFAB } from "react-native-paper";

const MyComponent = ({
  animatedValue,
  visible,
  extended,
  label,
  animateFrom,
  style,
  iconMode,
}) => {
  const [isExtended, setIsExtended] = React.useState(true);

  const isIOS = Platform.OS === "ios";

  const onScroll = ({ nativeEvent }) => {
    const currentScrollPosition =
      Math.floor(nativeEvent?.contentOffset?.y) ?? 0;

    setIsExtended(currentScrollPosition <= 0);
  };

  const fabStyle = { [animateFrom]: 16 };

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView onScroll={onScroll}>
        {[...new Array(100).keys()].map((_, i) => (
          <Text>{i}</Text>
        ))}
      </ScrollView>
      <AnimatedFAB
        icon={"plus"}
        label={"Label"}
        extended={isExtended}
        onPress={() => console.log("Pressed")}
        visible={visible}
        animateFrom={"right"}
        iconMode={"static"}
        style={[styles.fabStyle, style, fabStyle]}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flexGrow: 1,
  },
  fabStyle: {
    bottom: 16,
    right: 16,
    position: "absolute",
  },
});
```

#### Propiedades

- **icon**: IconSource (requerido) - Icono a mostrar en el FAB.
- **label**: string (requerido) - Etiqueta para el FAB extendido.
- **uppercase**: boolean - Hace que el texto de la etiqueta esté en mayúsculas.
- **background**: PressableAndroidRippleConfig - Tipo de fondo para mostrar el feedback (Android).
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el FAB. Usa label por defecto si está especificado.
- **accessibilityState**: AccessibilityState - Estado de accesibilidad para el FAB.
- **color**: string - Color personalizado para el icono y la etiqueta del FAB.
- **rippleColor**: ColorValue - Color del efecto de ondulación.
- **disabled**: boolean - Determina si el FAB está deshabilitado.
- **visible**: boolean - Determina si el FAB está actualmente visible. Valor por defecto: true.
- **onPress**: function - Función a ejecutar al presionar.
- **onLongPress**: function - Función a ejecutar al mantener presionado.
- **delayLongPress**: number - Número de milisegundos que un usuario debe tocar el elemento antes de ejecutar onLongPress.
- **iconMode**: 'static' | 'dynamic' - Indica si el icono debe traducirse al final del FAB extendido o permanecer estático en el mismo lugar. Valor por defecto: 'dynamic'.
- **animateFrom**: 'left' | 'right' - Indica desde qué dirección se debe realizar la animación. Valor por defecto: 'right'.
- **extended**: boolean - Determina si el FAB debe iniciar la animación para extenderse. Valor por defecto: false.
- **labelMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente de la etiqueta.
- **variant**: 'primary' | 'secondary' | 'tertiary' | 'surface' - Variante de mapeo de colores para combinaciones de colores de contenedor e icono. Valor por defecto: 'primary'.
- **style**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo personalizado para el FAB.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **testID**: string - ID de prueba utilizado con fines de testing. Valor por defecto: 'animated-fab'.

### HelperText

El componente HelperText se utiliza junto con elementos de entrada para proporcionar sugerencias adicionales al usuario.

#### Uso

```jsx
import * as React from "react";
import { View } from "react-native";
import { HelperText, TextInput } from "react-native-paper";

const MyComponent = () => {
  const [text, setText] = React.useState("");

  const onChangeText = (text) => setText(text);

  const hasErrors = () => {
    return !text.includes("@");
  };

  return (
    <View>
      <TextInput label="Email" value={text} onChangeText={onChangeText} />
      <HelperText type="error" visible={hasErrors()}>
        Email address is invalid!
      </HelperText>
    </View>
  );
};
```

#### Propiedades

- **type**: 'error' | 'info' - Tipo del texto de ayuda. Valor por defecto: 'info'.
- **children**: React.ReactNode (requerido) - Contenido de texto del HelperText.
- **visible**: boolean - Determina si se muestra el texto de ayuda. Valor por defecto: true.
- **padding**: 'none' | 'normal' - Determina si se aplica relleno al texto de ayuda. Valor por defecto: 'normal'.
- **disabled**: boolean - Determina si la entrada de texto vinculada con el texto de ayuda está deshabilitada.
- **style**: StyleProp<TextStyle> - Estilo personalizado para el texto de ayuda.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **testID**: string - ID de prueba utilizado con fines de testing.

### Icon

Un componente de icono que renderiza iconos de bibliotecas vectoriales.

#### Uso

```jsx
import * as React from "react";
import { Icon, MD3Colors } from "react-native-paper";

const MyComponent = () => (
  <Icon source="camera" color={MD3Colors.error50} size={20} />
);
```

#### Propiedades

- **size**: number (requerido) - Tamaño del icono.
- **allowFontScaling**: boolean - Permite el escalado de fuente.
- **source**: any (requerido) - Icono a mostrar.
- **color**: string - Color del icono.
- **testID**: string - ID de prueba utilizado con fines de testing.
- **theme**: ThemeProp - Tema para aplicar al componente.

### IconButton

Un botón de icono es un botón que muestra solo un icono sin etiqueta.

Estilos disponibles:

- default
- outlined
- contained
- contained-tonal

#### Uso

```jsx
import * as React from "react";
import { IconButton, MD3Colors } from "react-native-paper";

const MyComponent = () => (
  <IconButton
    icon="camera"
    iconColor={MD3Colors.error50}
    size={20}
    onPress={() => console.log("Pressed")}
  />
);
```

#### Propiedades

- **TouchableRipple props** - Extiende las propiedades de TouchableRipple.
- **icon**: IconSource (requerido) - Icono a mostrar.
- **mode**: 'outlined' | 'contained' | 'contained-tonal' - Modo del botón de icono. Por defecto no hay un modo específico, solo se renderizará el icono presionable. Disponible en v5.x con la versión 3 del tema.
- **iconColor**: string - Color del icono. Renombrado de 'color' a 'iconColor' en v5.x.
- **containerColor**: string - Color de fondo del contenedor del icono.
- **rippleColor**: ColorValue - Color del efecto de ondulación.
- **selected**: boolean - Determina si el botón de icono está seleccionado. Un botón seleccionado recibe una combinación alternativa de colores de icono y contenedor. Disponible en v5.x con la versión 3 del tema. Valor por defecto: false.
- **size**: number - Tamaño del icono. Valor por defecto: 24.
- **disabled**: boolean - Determina si el botón está deshabilitado. Un botón deshabilitado aparece en gris y no se llama a onPress al tocarlo.
- **animated**: boolean - Determina si el cambio de icono está animado. Valor por defecto: false.
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el botón. Esto es leído por el lector de pantalla cuando el usuario toca el botón.
- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar.
- **style**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo personalizado para el botón.
- **ref**: React.RefObject<View> - Referencia para el componente.
- **testID**: string - ID de prueba utilizado con fines de testing. Valor por defecto: 'icon-button'.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **loading**: boolean - Determina si se muestra un indicador de carga. Valor por defecto: false.

### List.Accordion

El componente List.Accordion se utiliza para mostrar un elemento de lista expandible.

#### Uso

```jsx
import * as React from "react";
import { List } from "react-native-paper";

const MyComponent = () => {
  const [expanded, setExpanded] = React.useState(true);

  const handlePress = () => setExpanded(!expanded);

  return (
    <List.Section title="Accordions">
      <List.Accordion
        title="Uncontrolled Accordion"
        left={(props) => <List.Icon {...props} icon="folder" />}
      >
        <List.Item title="First item" />
        <List.Item title="Second item" />
      </List.Accordion>

      <List.Accordion
        title="Controlled Accordion"
        left={(props) => <List.Icon {...props} icon="folder" />}
        expanded={expanded}
        onPress={handlePress}
      >
        <List.Item title="First item" />
        <List.Item title="Second item" />
      </List.Accordion>
    </List.Section>
  );
};
```

#### Propiedades

- **title**: React.ReactNode (requerido) - Texto del título para el acordeón.
- **description**: React.ReactNode - Texto de descripción para el acordeón.
- **left**: (props: { color: string; style: Style }) => React.ReactNode - Callback que devuelve un elemento React para mostrar en el lado izquierdo.
- **right**: (props: { isExpanded: boolean }) => React.ReactNode - Callback que devuelve un elemento React para mostrar en el lado derecho.
- **expanded**: boolean - Determina si el acordeón está expandido. Si se proporciona, el acordeón se comportará como un "componente controlado". Necesitarás actualizar esta prop cuando desees alternar el componente o en onPress.
- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar.
- **onLongPress**: (e: GestureResponderEvent) => void - Función a ejecutar al mantener presionado.
- **delayLongPress**: number - Número de milisegundos que un usuario debe tocar el elemento antes de ejecutar onLongPress.
- **children**: React.ReactNode (requerido) - Contenido de la sección.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **background**: PressableAndroidRippleConfig - Tipo de fondo a mostrar para el feedback (Android).
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el elemento TouchableRipple.
- **titleStyle**: StyleProp<TextStyle> - Estilo personalizado para el elemento Title.
- **descriptionStyle**: StyleProp<TextStyle> - Estilo personalizado para el elemento Description.
- **rippleColor**: ColorValue - Color del efecto de ondulación.
- **titleNumberOfLines**: number - Trunca el texto del título para que no exceda este número de líneas. Valor por defecto: 1.
- **descriptionNumberOfLines**: number - Trunca el texto de la descripción para que no exceda este número de líneas. Valor por defecto: 2.
- **titleMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente del título.
- **descriptionMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente de la descripción.
- **id**: string | number - ID utilizado para distinguir un acordeón específico cuando se utiliza List.AccordionGroup. Esta propiedad es requerida cuando se utiliza List.AccordionGroup y no tiene impacto en el comportamiento cuando se utiliza List.Accordion de forma independiente.
- **testID**: string - ID de prueba utilizado con fines de testing.
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el TouchableRipple. Esto es leído por el lector de pantalla cuando el usuario toca el elemento.
- **pointerEvents**: ViewProps['pointerEvents'] - Eventos de puntero pasados a la vista del contenedor. Valor por defecto: 'none'.

### Menu.Item

Un componente para mostrar un único elemento de lista dentro de un Menú.

#### Uso

```jsx
import * as React from "react";
import { View } from "react-native";
import { Menu } from "react-native-paper";

const MyComponent = () => (
  <View style={{ flex: 1 }}>
    <Menu.Item leadingIcon="redo" onPress={() => {}} title="Redo" />
    <Menu.Item leadingIcon="undo" onPress={() => {}} title="Undo" />
    <Menu.Item
      leadingIcon="content-cut"
      onPress={() => {}}
      title="Cut"
      disabled
    />
    <Menu.Item
      leadingIcon="content-copy"
      onPress={() => {}}
      title="Copy"
      disabled
    />
    <Menu.Item leadingIcon="content-paste" onPress={() => {}} title="Paste" />
  </View>
);
```

#### Propiedades

- **title**: React.ReactNode (requerido) - Texto del título para el elemento del menú.
- **leadingIcon**: IconSource - Icono principal a mostrar para el elemento del menú. Renombrado de 'icon' a 'leadingIcon' en v5.x.
- **trailingIcon**: IconSource - Icono secundario a mostrar para el elemento del menú. Disponible en v5.x con versión de tema 3.
- **disabled**: boolean - Determina si el elemento está deshabilitado. Un elemento deshabilitado aparece en gris y no se llama a onPress al tocarlo.
- **dense**: boolean - Establece la altura mínima con diseño compacto. Disponible en v5.x con versión de tema 3.
- **background**: PressableAndroidRippleConfig - Tipo de fondo drawable para mostrar el feedback (Android). https://reactnative.dev/docs/pressable#rippleconfig
- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar.
- **titleMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente del título. Valor por defecto: 1.5.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el elemento.
- **contentStyle**: StyleProp<ViewStyle> - Estilo personalizado para el contenido.
- **titleStyle**: StyleProp<TextStyle> - Estilo personalizado para el título.
- **rippleColor**: ColorValue - Color del efecto de ondulación.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **testID**: string - ID de prueba utilizado con fines de testing. Valor por defecto: 'menu-item'.
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el Touchable. Esto es leído por el lector de pantalla cuando el usuario toca el componente.
- **accessibilityState**: AccessibilityState - Estado de accesibilidad para el Touchable. Esto es leído por el lector de pantalla cuando el usuario toca el componente.

### List.AccordionGroup

El componente List.AccordionGroup permite controlar un grupo de List.Accordion. La prop id para List.Accordion es necesaria para que el grupo funcione. List.AccordionGroup puede ser un componente controlado o no controlado. El ejemplo muestra la versión no controlada. Solamente un Accordion puede estar expandido en un momento dado.

#### Uso

```jsx
import * as React from "react";
import { View, Text } from "react-native";
import { List } from "react-native-paper";

const MyComponent = () => (
  <List.AccordionGroup>
    <List.Accordion title="Accordion 1" id="1">
      <List.Item title="Item 1" />
    </List.Accordion>
    <List.Accordion title="Accordion 2" id="2">
      <List.Item title="Item 2" />
    </List.Accordion>
    <View>
      <Text>
        List.Accordion puede ser envuelto porque la implementación utiliza
        React.Context.
      </Text>
      <List.Accordion title="Accordion 3" id="3">
        <List.Item title="Item 3" />
      </List.Accordion>
    </View>
  </List.AccordionGroup>
);
```

#### Propiedades

- **onAccordionPress**: (expandedId: string | number) => void - Función a ejecutar al cambiar la selección.
- **expandedId**: string | number - ID del acordeón actualmente expandido.
- **children**: React.ReactNode (requerido) - Elementos React que contienen acordeones de lista.

### List.Icon

Un componente para mostrar un icono en un elemento de lista.

#### Uso

```jsx
import * as React from "react";
import { List, MD3Colors } from "react-native-paper";

const MyComponent = () => (
  <>
    <List.Icon color={MD3Colors.tertiary70} icon="folder" />
    <List.Icon color={MD3Colors.tertiary70} icon="equal" />
    <List.Icon color={MD3Colors.tertiary70} icon="calendar" />
  </>
);
```

#### Propiedades

- **icon**: IconSource (requerido) - Icono a mostrar.
- **color**: string - Color para el icono.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el icono.
- **theme**: ThemeProp - Tema para aplicar al componente.

### List.Item

Un componente para mostrar elementos dentro de una Lista.

#### Uso

```jsx
import * as React from "react";
import { List } from "react-native-paper";

const MyComponent = () => (
  <List.Item
    title="First Item"
    description="Item description"
    left={(props) => <List.Icon {...props} icon="folder" />}
  />
);
```

#### Propiedades

- **TouchableRipple props** - Extiende las propiedades de TouchableRipple.
- **title**: React.ReactNode | ((props: { selectable: boolean; ellipsizeMode: EllipsizeProp | undefined; color: string; fontSize: number; }) => React.ReactNode) (requerido) - Texto del título para el elemento de lista.
- **description**: React.ReactNode | ((props: { selectable: boolean; ellipsizeMode: EllipsizeProp | undefined; color: string; fontSize: number; }) => React.ReactNode) - Texto de descripción para el elemento de lista o callback que devuelve un elemento React para mostrar la descripción.
- **left**: (props: { color: string; style: Style }) => React.ReactNode - Callback que devuelve un elemento React para mostrar en el lado izquierdo.
- **right**: (props: { color: string; style?: Style }) => React.ReactNode - Callback que devuelve un elemento React para mostrar en el lado derecho.
- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el elemento TouchableRipple.
- **contentStyle**: StyleProp<ViewStyle> - Estilo personalizado para el contenedor que envuelve el título y la descripción.
- **titleStyle**: StyleProp<TextStyle> - Estilo personalizado para el elemento Title.
- **descriptionStyle**: StyleProp<TextStyle> - Estilo personalizado para el elemento Description.
- **titleNumberOfLines**: number - Trunca el texto del título para que no exceda este número de líneas. Valor por defecto: 1.
- **descriptionNumberOfLines**: number - Trunca el texto de la descripción para que no exceda este número de líneas. Valor por defecto: 2.
- **titleEllipsizeMode**: EllipsizeProp - Modo de elipsis para el título. Uno de 'head', 'middle', 'tail', 'clip'.
- **descriptionEllipsizeMode**: EllipsizeProp - Modo de elipsis para la descripción. Uno de 'head', 'middle', 'tail', 'clip'.
- **titleMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente del título.
- **descriptionMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente de la descripción.
- **testID**: string - ID de prueba utilizado con fines de testing.

### List.Section

Un componente utilizado para agrupar elementos de lista.

#### Uso

```jsx
import * as React from "react";
import { List, MD3Colors } from "react-native-paper";

const MyComponent = () => (
  <List.Section>
    <List.Subheader>Some title</List.Subheader>
    <List.Item title="First Item" left={() => <List.Icon icon="folder" />} />
    <List.Item
      title="Second Item"
      left={() => <List.Icon color={MD3Colors.tertiary70} icon="folder" />}
    />
  </List.Section>
);
```

#### Propiedades

- **title**: string - Texto del título para la sección.
- **children**: React.ReactNode (requerido) - Contenido de la sección.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **titleStyle**: StyleProp<TextStyle> - Estilo personalizado para el elemento Title.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para la sección.

### List.Subheader

Un componente utilizado para mostrar un encabezado en listas.

#### Uso

```jsx
import * as React from "react";
import { List } from "react-native-paper";

const MyComponent = () => <List.Subheader>My List Title</List.Subheader>;
```

#### Propiedades

- **theme**: ThemeProp - Tema para aplicar al componente.
- **style**: StyleProp<TextStyle> - Estilo personalizado para el elemento Text.
- **maxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente de texto.

### FAB.Group

Un componente para mostrar un grupo de FABs con acciones relacionadas en un marcado de velocidad. Para renderizar el grupo por encima de otros componentes, necesitarás envolverlo con el componente Portal.

#### Uso

```jsx
import * as React from "react";
import { FAB, Portal, PaperProvider } from "react-native-paper";

const MyComponent = () => {
  const [state, setState] = React.useState({ open: false });

  const onStateChange = ({ open }) => setState({ open });

  const { open } = state;

  return (
    <PaperProvider>
      <Portal>
        <FAB.Group
          open={open}
          visible
          icon={open ? "calendar-today" : "plus"}
          actions={[
            { icon: "plus", onPress: () => console.log("Pressed add") },
            {
              icon: "star",
              label: "Star",
              onPress: () => console.log("Pressed star"),
            },
            {
              icon: "email",
              label: "Email",
              onPress: () => console.log("Pressed email"),
            },
            {
              icon: "bell",
              label: "Remind",
              onPress: () => console.log("Pressed notifications"),
            },
          ]}
          onStateChange={onStateChange}
          onPress={() => {
            if (open) {
              // do something if the speed dial is open
            }
          }}
        />
      </Portal>
    </PaperProvider>
  );
};
```

#### Propiedades

- **actions**: Array (requerido) - Elementos de acción para mostrar en forma de marcado de velocidad. Un elemento de acción debe contener las siguientes propiedades:
  - icon: icono a mostrar (requerido)
  - label: texto de etiqueta opcional
  - color: color de icono personalizado del elemento de acción
  - labelTextColor: color de texto de etiqueta personalizado del elemento de acción
  - accessibilityLabel: etiqueta de accesibilidad para la acción, usa label por defecto si está especificado
  - accessibilityHint: sugerencia de accesibilidad para la acción
  - style: estilos adicionales para el elemento fab
  - containerStyle: estilos adicionales para el contenedor de etiqueta del elemento fab
  - labelStyle: estilos adicionales para la etiqueta del elemento fab
  - labelMaxFontSizeMultiplier: especifica la escala más grande posible que puede alcanzar la fuente de un título
  - onPress: callback que se llama cuando se presiona el FAB (requerido)
  - onLongPress: callback que se llama cuando se mantiene presionado el FAB
  - toggleStackOnLongPress: callback que se llama cuando se mantiene presionado el FAB
  - size: tamaño del elemento de acción. Por defecto es small
  - testID: testID para usar en pruebas
  - rippleColor: color del efecto de ondulación
- **icon**: IconSource (requerido) - Icono a mostrar para el FAB. Puedes alternarlo según si el marcado de velocidad está abierto para mostrar un icono diferente.
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el FAB.
- **color**: string - Color personalizado para el FAB.
- **backdropColor**: string - Color de fondo personalizado para el fondo del marcado de velocidad abierto.
- **rippleColor**: ColorValue - Color del efecto de ondulación.
- **onPress**: function - Función a ejecutar al presionar el FAB.
- **onLongPress**: function - Función a ejecutar al mantener presionado el FAB.
- **toggleStackOnLongPress**: boolean - Hace que las acciones aparezcan al mantener presionado en lugar de al presionar.
- **delayLongPress**: number - Cambia el retraso para la reacción de presión larga. Valor por defecto: 200.
- **enableLongPressWhenStackOpened**: boolean - Permite onLongPress cuando la pila está abierta. Valor por defecto: false.
- **open**: boolean (requerido) - Determina si el marcado de velocidad está abierto.
- **onStateChange**: function (requerido) - Callback que se llama al abrir y cerrar el marcado de velocidad.
- **visible**: boolean (requerido) - Determina si FAB está actualmente visible.
- **style**: StyleProp<ViewStyle> - Estilo para el grupo.
- **fabStyle**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo para el FAB.
- **variant**: 'primary' | 'secondary' | 'tertiary' | 'surface' - Variante de mapeo de colores para combinaciones de colores de contenedor e icono. Valor por defecto: 'primary'.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **label**: string - Etiqueta opcional para FAB.
- **testID**: string - ID de prueba para pasar desde las props del Grupo al FAB.

### Modal

El componente Modal es una forma simple de presentar contenido por encima de una vista envolvente. Para renderizar el Modal por encima de otros componentes, necesitarás envolverlo con el componente Portal.

#### Uso

```jsx
import * as React from "react";
import { Modal, Portal, Text, Button, PaperProvider } from "react-native-paper";

const MyComponent = () => {
  const [visible, setVisible] = React.useState(false);

  const showModal = () => setVisible(true);
  const hideModal = () => setVisible(false);
  const containerStyle = { backgroundColor: "white", padding: 20 };

  return (
    <PaperProvider>
      <Portal>
        <Modal
          visible={visible}
          onDismiss={hideModal}
          contentContainerStyle={containerStyle}
        >
          <Text>Example Modal. Click outside this area to dismiss.</Text>
        </Modal>
      </Portal>
      <Button style={{ marginTop: 30 }} onPress={showModal}>
        Show
      </Button>
    </PaperProvider>
  );
};
```

#### Propiedades

- **dismissable**: boolean - Determina si hacer clic fuera del modal lo cierra. Valor por defecto: true.
- **dismissableBackButton**: boolean - Determina si al presionar el botón de hardware Atrás de Android se cierra el diálogo. Valor por defecto: valor de dismissable.
- **onDismiss**: () => void - Función que se llama cuando el usuario cierra el modal. Valor por defecto: () => {}.
- **overlayAccessibilityLabel**: string - Etiqueta de accesibilidad para la superposición. Esto es leído por el lector de pantalla cuando el usuario toca fuera del modal. Valor por defecto: 'Close modal'.
- **visible**: boolean - Determina si el modal es visible. Valor por defecto: false.
- **children**: React.ReactNode (requerido) - Contenido del Modal.
- **contentContainerStyle**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo para el contenido del modal.
- **style**: StyleProp<ViewStyle> - Estilo para el contenedor del modal. Usa esta prop para cambiar el estilo del contenedor predeterminado o para sobrescribir los márgenes de seguridad con marginTop y marginBottom.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **testID**: string - ID de prueba utilizado con fines de testing. Valor por defecto: 'modal'.

### Portal

El componente Portal permite renderizar un componente en un lugar diferente del árbol de componentes padre. Puedes usarlo para renderizar contenido que debería aparecer por encima de otros elementos, similar a Modal. Requiere que un componente Portal.Host se renderice en algún lugar del árbol padre. Ten en cuenta que si estás usando el componente Provider, este ya incluye un Portal.Host.

#### Uso

```jsx
import * as React from "react";
import { Portal, Text } from "react-native-paper";

const MyComponent = () => (
  <Portal>
    <Text>Esto se renderiza en un lugar diferente</Text>
  </Portal>
);
```

#### Propiedades

- **children**: React.ReactNode (requerido) - Contenido del Portal.
- **theme**: InternalTheme - Tema para aplicar al componente.

### Portal.Host

Portal.Host renderiza todos sus elementos Portal hijos. Por ejemplo, puedes envolver una pantalla en Portal.Host para renderizar elementos por encima de la pantalla. Si estás usando el componente Provider, este ya incluye Portal.Host.

#### Uso

```jsx
import * as React from "react";
import { Text } from "react-native";
import { Portal } from "react-native-paper";

const MyComponent = () => (
  <Portal.Host>
    <Text>Contenido de la aplicación</Text>
  </Portal.Host>
);
```

Aquí, cualquier elemento Portal bajo `<App />` se renderiza junto a `<App />` y aparecerá por encima de `<App />` como un Modal.

#### Propiedades

- **children**: React.ReactNode (requerido) - Contenido del Portal.Host.

### ProgressBar

El componente ProgressBar es un indicador utilizado para mostrar el progreso de alguna actividad en la aplicación.

#### Uso

```jsx
import * as React from "react";
import { ProgressBar, MD3Colors } from "react-native-paper";

const MyComponent = () => (
  <ProgressBar progress={0.5} color={MD3Colors.error50} />
);
```

#### Propiedades

- **animatedValue**: number - Valor animado (entre 0 y 1). Esto indica a la barra de progreso que debe basarse en este valor para animarse. Nota: No debe usarse en paralelo con la prop progress.
- **progress**: number - Valor de progreso (entre 0 y 1). Valor por defecto: 0. Nota: No debe usarse en paralelo con la prop animatedValue.
- **color**: string - Color de la barra de progreso. El color de fondo se calculará en base a este, pero puedes cambiarlo pasando backgroundColor a la prop style.
- **indeterminate**: boolean - Si la barra de progreso mostrará un progreso indeterminado.
- **visible**: boolean - Determina si se muestra la barra de progreso (true, por defecto) o se oculta (false). Valor por defecto: true.
- **fillStyle**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo de la parte llena de la barra de progreso.
- **style**: StyleProp<ViewStyle> - Estilo personalizado para la barra de progreso.
- **theme**: ThemeProp - Tema para aplicar al componente.
- **testID**: string - ID de prueba utilizado con fines de testing. Valor por defecto: 'progress-bar'.

### RadioButton

El componente RadioButton permite la selección de una única opción de un conjunto. Este componente sigue las pautas de la plataforma para Android e iOS, pero puede usarse en cualquier plataforma.

#### RadioButton.Android

Los radio buttons permiten la selección de una única opción de un conjunto. Este componente sigue las pautas de la plataforma para Android, pero puede usarse en cualquier plataforma.

##### Propiedades

- **value** (requerido): string - Valor del radio button
- **status**: 'checked' | 'unchecked' - Estado del radio button
- **disabled**: boolean - Si el radio button está deshabilitado
- **onPress**: (param?: any) => void - Función a ejecutar al presionar
- **uncheckedColor**: string - Color personalizado para el estado sin marcar
- **color**: string - Color personalizado para el radio button
- **theme**: ThemeProp - Tema del componente
- **testID**: string - ID para pruebas

#### RadioButton.Group

El grupo de radio buttons permite controlar un conjunto de radio buttons.

##### Uso

```jsx
import * as React from "react";
import { View } from "react-native";
import { RadioButton, Text } from "react-native-paper";

const MyComponent = () => {
  const [value, setValue] = React.useState("first");

  return (
    <RadioButton.Group
      onValueChange={(newValue) => setValue(newValue)}
      value={value}
    >
      <View>
        <Text>First</Text>
        <RadioButton value="first" />
      </View>
      <View>
        <Text>Second</Text>
        <RadioButton value="second" />
      </View>
    </RadioButton.Group>
  );
};
```

##### Propiedades

- **onValueChange** (requerido): (value: string) => void - Función a ejecutar al cambiar la selección
- **value** (requerido): string - Valor del radio button actualmente seleccionado
- **children** (requerido): React.ReactNode - Elementos React que contienen radio buttons

#### RadioButton.IOS

##### Propiedades

- **value** (requerido): string - Valor del radio button
- **status**: 'checked' | 'unchecked' - Estado del radio button
- **disabled**: boolean - Si el radio button está deshabilitado
- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar
- **color**: string - Color personalizado para el radio button
- **theme**: ThemeProp - Tema del componente
- **testID**: string - ID para pruebas

#### RadioButton.Item

RadioButton.Item permite presionar toda la fila (item) en lugar de solo el RadioButton.

##### Uso

```jsx
import * as React from "react";
import { RadioButton } from "react-native-paper";

const MyComponent = () => {
  const [value, setValue] = React.useState("first");

  return (
    <RadioButton.Group onValueChange={(value) => setValue(value)} value={value}>
      <RadioButton.Item label="First item" value="first" />
      <RadioButton.Item label="Second item" value="second" />
    </RadioButton.Group>
  );
};
```

##### Propiedades

- **value** (requerido): string - Valor del radio button
- **label** (requerido): string - Etiqueta a mostrar en el item
- **disabled**: boolean - Si el radio button está deshabilitado
- **background**: PressableAndroidRippleConfig - Tipo de fondo para mostrar el feedback (Android)
- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar
- **onLongPress**: (e: GestureResponderEvent) => void - Función a ejecutar al mantener presionado
- **accessibilityLabel**: string - Etiqueta de accesibilidad para el touchable
- **uncheckedColor**: string - Color personalizado para el estado sin marcar
- **color**: string - Color personalizado para el radio button
- **rippleColor**: ColorValue - Color del efecto ripple
- **status**: 'checked' | 'unchecked' - Estado del radio button
- **style**: StyleProp<ViewStyle> - Estilos adicionales para el contenedor View
- **labelStyle**: StyleProp<TextStyle> - Estilo para el elemento Label
- **labelVariant**: string - Variante del texto de la etiqueta (disponible en v5.x con theme version 3)
- **labelMaxFontSizeMultiplier**: number - Especifica la escala máxima que puede alcanzar la fuente de la etiqueta
- **theme**: ThemeProp - Tema del componente
- **testID**: string - ID para pruebas
- **mode**: 'android' | 'ios' - Si se debe usar <RadioButton.Android /> o <RadioButton.IOS />
- **position**: 'leading' | 'trailing' - Posición del control del radio button

### Searchbar

El componente Searchbar es una caja de entrada simple donde los usuarios pueden escribir consultas de búsqueda.

#### Uso

```jsx
import * as React from "react";
import { Searchbar } from "react-native-paper";

const MyComponent = () => {
  const [searchQuery, setSearchQuery] = React.useState("");

  return (
    <Searchbar
      placeholder="Search"
      onChangeText={setSearchQuery}
      value={searchQuery}
    />
  );
};
```

#### Propiedades

- **placeholder**: string - Texto de sugerencia que se muestra cuando la entrada está vacía.
- **value** (requerido): string - El valor del campo de texto.
- **onChangeText**: (query: string) => void - Función que se llama cuando cambia el texto.
- **mode**: 'bar' | 'view' - (Disponible en v5.x con theme version 3) Modo de diseño de búsqueda. Valor por defecto: 'bar'.
- **icon**: IconSource - Nombre del icono para el botón de icono izquierdo.
- **iconColor**: string - Color personalizado para el icono.
- **rippleColor**: ColorValue - Color del efecto de ondulación.
- **onIconPress**: (e: GestureResponderEvent) => void - Función a ejecutar si queremos que el icono izquierdo actúe como botón.
- **onClearIconPress**: (e: GestureResponderEvent) => void - Función a ejecutar si queremos añadir comportamiento personalizado al botón de icono de cierre.
- **searchAccessibilityLabel**: string - Etiqueta de accesibilidad para el botón. Valor por defecto: 'search'.
- **clearIcon**: IconSource - Icono personalizado para el botón de limpiar.
- **clearAccessibilityLabel**: string - Etiqueta de accesibilidad para el botón de limpiar. Valor por defecto: 'clear'.
- **traileringIcon**: IconSource - (Disponible en v5.x con theme version 3) Icono para el botón de icono derecho.
- **traileringIconColor**: string - Color personalizado para el icono derecho.
- **traileringRippleColor**: ColorValue - Color del efecto de ondulación del icono derecho.
- **onTraileringIconPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar el icono derecho.
- **traileringIconAccessibilityLabel**: string - Etiqueta de accesibilidad para el botón de icono derecho.
- **right**: (props: { color: string; style: Style; testID: string; }) => React.ReactNode - Callback que devuelve un elemento React para mostrar en el lado derecho.
- **showDivider**: boolean - (Disponible en v5.x con theme version 3) Si se debe mostrar el Divider en la parte inferior. Valor por defecto: true.
- **elevation**: 0 | 1 | 2 | 3 | 4 | 5 | Animated.Value - Cambia la sombra y el fondo en iOS y Android. Valor por defecto: 0.
- **inputStyle**: StyleProp<TextStyle> - Estilo del componente TextInput dentro del searchbar.
- **style**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo personalizado para el componente.
- **loading**: boolean - Bandera personalizada para reemplazar el botón de limpiar con un indicador de actividad. Valor por defecto: false.
- **testID**: string - ID de prueba utilizado con fines de testing. Valor por defecto: 'search-bar'.
- **theme**: ThemeProp - Tema para aplicar al componente.

### SegmentedButtons

Los botones segmentados se pueden usar para seleccionar opciones, cambiar vistas o ordenar elementos. Soportan selección única y selección múltiple.

#### Uso

```jsx
import * as React from "react";
import { SafeAreaView, StyleSheet } from "react-native";
import { SegmentedButtons } from "react-native-paper";

const MyComponent = () => {
  const [value, setValue] = React.useState("");

  return (
    <SafeAreaView style={styles.container}>
      <SegmentedButtons
        value={value}
        onValueChange={setValue}
        buttons={[
          {
            value: "walk",
            label: "Walking",
          },
          {
            value: "train",
            label: "Transit",
          },
          { value: "drive", label: "Driving" },
        ]}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
  },
});
```

#### Propiedades

- **buttons** (requerido): Array - Botones a mostrar como opciones. Cada botón debe contener las siguientes propiedades:

  - **value**: string (requerido) - Valor del botón
  - **icon**: IconSource - Icono a mostrar para el elemento
  - **disabled**: boolean - Si el botón está deshabilitado
  - **accessibilityLabel**: string - Etiqueta de accesibilidad para el botón
  - **checkedColor**: string - Color personalizado para el texto e icono cuando está seleccionado
  - **uncheckedColor**: string - Color personalizado para el texto e icono cuando no está seleccionado
  - **onPress**: (event: GestureResponderEvent) => void - Función a ejecutar al presionar
  - **label**: string - Texto de la etiqueta del botón
  - **showSelectedCheck**: boolean - Mostrar icono opcional de verificación para indicar estado seleccionado
  - **style**: StyleProp<ViewStyle> - Estilos adicionales para el botón
  - **labelStyle**: StyleProp<TextStyle> - Estilos adicionales para la etiqueta
  - **testID**: string - ID para pruebas

- **density**: 'regular' | 'small' | 'medium' | 'high' - La densidad se aplica a la altura, para permitir su uso en interfaces más densas
- **style**: StyleProp<ViewStyle> - Estilo personalizado para el componente
- **theme**: ThemeProp - Tema para aplicar al componente

### Snackbar

Los Snackbars proporcionan retroalimentación breve sobre una operación a través de un mensaje renderizado en la parte inferior del contenedor en el que está envuelto.

Nota: Para mostrarlo como un popup, independientemente de la posición del padre, envuélvelo con un componente Portal.

#### Uso

```jsx
import * as React from "react";
import { View, StyleSheet } from "react-native";
import { Button, Snackbar } from "react-native-paper";

const MyComponent = () => {
  const [visible, setVisible] = React.useState(false);

  const onToggleSnackBar = () => setVisible(!visible);

  const onDismissSnackBar = () => setVisible(false);

  return (
    <View style={styles.container}>
      <Button onPress={onToggleSnackBar}>{visible ? "Hide" : "Show"}</Button>
      <Snackbar
        visible={visible}
        onDismiss={onDismissSnackBar}
        action={{
          label: "Undo",
          onPress: () => {
            // Do something
          },
        }}
      >
        Hey there! I'm a Snackbar.
      </Snackbar>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "space-between",
  },
});
```

#### Propiedades

- **visible** (requerido): boolean - Determina si el Snackbar está actualmente visible.

- **action**: $RemoveChildren<typeof Button> & { label: string; } - Etiqueta y callback de presión para el botón de acción. Debe contener las siguientes propiedades:

  - **label**: string - Etiqueta del botón de acción
  - **onPress**: function - Callback que se llama cuando se presiona el botón de acción

- **icon**: IconSource - (Disponible en v5.x con theme version 3) Icono a mostrar cuando onIconPress está definido. Por defecto será el icono de cierre.

- **rippleColor**: ColorValue - (Disponible en v5.x con theme version 3) Color del efecto de ondulación.

- **onIconPress**: () => void - (Disponible en v5.x con theme version 3) Función a ejecutar al presionar el botón de icono. El botón de icono aparece solo cuando se especifica esta prop.

- **iconAccessibilityLabel**: string - (Disponible en v5.x con theme version 3) Etiqueta de accesibilidad para el botón de icono. Esto es leído por el lector de pantalla cuando el usuario toca el botón. Valor por defecto: 'Close icon'.

- **duration**: number - La duración durante la cual se muestra el Snackbar. Valor por defecto: 7000.

- **onDismiss** (requerido): () => void - Callback llamado cuando se descarta el Snackbar. La prop visible debe actualizarse cuando se llama a esto.

- **children** (requerido): React.ReactNode - Contenido de texto del Snackbar.

- **elevation**: 0 | 1 | 2 | 3 | 4 | 5 | Animated.Value - (Disponible en v5.x con theme version 3) Cambia la sombra y el fondo del Snackbar en iOS y Android. Valor por defecto: 2.

- **maxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente del texto.

- **wrapperStyle**: StyleProp<ViewStyle> - Estilo para el contenedor del snackbar.

- **style**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo personalizado para el Snackbar.

- **ref**: React.RefObject<View> - Referencia para el componente.

- **theme**: ThemeProp - Tema para aplicar al componente.

- **testID**: string - ID de prueba utilizado con fines de testing.

### Surface

Surface es un contenedor básico que puede dar profundidad a un elemento con sombra de elevación. En el tema oscuro con modo adaptativo, la superficie se construye también colocando una superposición blanca semitransparente sobre la superficie del componente. Consulta el tema oscuro para obtener más información. La superposición y la sombra se pueden aplicar especificando la propiedad de elevación tanto en Android como en iOS.

Modos disponibles:

- elevated
- flat

#### Uso

```jsx
import * as React from "react";
import { Surface, Text } from "react-native-paper";
import { StyleSheet } from "react-native";

const MyComponent = () => (
  <Surface style={styles.surface} elevation={4}>
    <Text>Surface</Text>
  </Surface>
);

const styles = StyleSheet.create({
  surface: {
    padding: 8,
    height: 80,
    width: 80,
    alignItems: "center",
    justifyContent: "center",
  },
});
```

#### Propiedades

- **children** (requerido): React.ReactNode - Contenido del Surface.

- **style**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo personalizado para el componente.

- **elevation**: 0 | 1 | 2 | 3 | 4 | 5 | Animated.Value - (Disponible en v5.x con theme version 3) Cambia las sombras y el fondo en iOS y Android. Se utiliza para crear jerarquía UI entre componentes. Valor por defecto: 1.

  Nota: Si el modo está establecido en flat, Surface no tiene sombra.

  Nota: En la versión 2, la prop elevation se aceptaba a través de la prop style, es decir, style={{ elevation: 4 }}. Ya no es compatible con la versión 3 del tema y debe usar la propiedad elevation en su lugar.

- **mode**: 'flat' | 'elevated' - (Disponible en v5.x con theme version 3) Modo del Surface. Valor por defecto: 'elevated'.

  - **elevated** - Surface con una sombra y color de fondo correspondiente al valor de elevación establecido.
  - **flat** - Surface sin sombra, con el color de fondo correspondiente al valor de elevación establecido.

- **theme**: ThemeProp - Tema para aplicar al componente.

- **testID**: string - ID de prueba utilizado con fines de testing. Valor por defecto: 'surface'.

- **ref**: React.RefObject<View> - Referencia para el componente.

### Switch

Switch es un interruptor visual entre dos estados mutuamente exclusivos: encendido y apagado.

Disponible para:

- Android (habilitado)
- Android (deshabilitado)
- iOS (habilitado)
- iOS (deshabilitado)

#### Uso

```jsx
import * as React from "react";
import { Switch } from "react-native-paper";

const MyComponent = () => {
  const [isSwitchOn, setIsSwitchOn] = React.useState(false);

  const onToggleSwitch = () => setIsSwitchOn(!isSwitchOn);

  return <Switch value={isSwitchOn} onValueChange={onToggleSwitch} />;
};
```

#### Propiedades

- **disabled**: boolean - Deshabilita la posibilidad de alternar el switch.

- **value**: boolean - Valor del switch, true significa 'encendido', false significa 'apagado'.

- **color**: string - Color personalizado para el switch.

- **onValueChange**: Function - Callback que se llama con el nuevo valor cuando cambia.

- **style**: StyleProp<ViewStyle> - Estilo personalizado para el switch.

- **theme**: ThemeProp - Tema para aplicar al componente.

### Text

Componente de tipografía que muestra estilos que cumplen con la prop variant proporcionada y son compatibles con el sistema de tipos.

#### Uso

```jsx
import * as React from "react";
import { Text } from "react-native-paper";

const MyComponent = () => (
  <>
    <Text variant="displayLarge">Display Large</Text>
    <Text variant="displayMedium">Display Medium</Text>
    <Text variant="displaySmall">Display small</Text>

    <Text variant="headlineLarge">Headline Large</Text>
    <Text variant="headlineMedium">Headline Medium</Text>
    <Text variant="headlineSmall">Headline Small</Text>

    <Text variant="titleLarge">Title Large</Text>
    <Text variant="titleMedium">Title Medium</Text>
    <Text variant="titleSmall">Title Small</Text>

    <Text variant="bodyLarge">Body Large</Text>
    <Text variant="bodyMedium">Body Medium</Text>
    <Text variant="bodySmall">Body Small</Text>

    <Text variant="labelLarge">Label Large</Text>
    <Text variant="labelMedium">Label Medium</Text>
    <Text variant="labelSmall">Label Small</Text>
  </>
);
```

#### Propiedades

- **...Text props** - Extiende todas las propiedades del componente Text de React Native.

- **variant**: VariantProp<T> - (Disponible en v5.x con theme version 3) Define los estilos de texto apropiados para el rol de tipo y su tamaño. Variantes disponibles:

  - **Display**: displayLarge, displayMedium, displaySmall
  - **Headline**: headlineLarge, headlineMedium, headlineSmall
  - **Title**: titleLarge, titleMedium, titleSmall
  - **Label**: labelLarge, labelMedium, labelSmall
  - **Body**: bodyLarge, bodyMedium, bodySmall

- **children** (requerido): React.ReactNode - Contenido del texto.

- **theme**: ThemeProp - Tema para aplicar al componente.

- **style**: StyleProp<TextStyle> - Estilo personalizado para el texto.

### TextInput

Un componente que permite a los usuarios ingresar texto.

Modos disponibles:

- flat (enfocado)
- flat (deshabilitado)
- outlined (enfocado)
- outlined (deshabilitado)

#### Uso

```jsx
import * as React from "react";
import { TextInput } from "react-native-paper";

const MyComponent = () => {
  const [text, setText] = React.useState("");

  return (
    <TextInput
      label="Email"
      value={text}
      onChangeText={(text) => setText(text)}
    />
  );
};
```

#### Propiedades

- **...TextInput props** - Extiende todas las propiedades del componente TextInput de React Native.

- **mode**: 'flat' | 'outlined' - Modo del TextInput. Valor por defecto: 'flat'.

  - **flat** - entrada plana con un subrayado.
  - **outlined** - entrada con un contorno.

- **left**: React.ReactNode - Elemento React para mostrar en el lado izquierdo.

- **right**: React.ReactNode - Elemento React para mostrar en el lado derecho.

- **disabled**: boolean - Si es true, el usuario no podrá interactuar con el componente. Valor por defecto: false.

- **label**: TextInputLabelProp - El texto o componente a usar para la etiqueta flotante.

- **placeholder**: string - Texto de marcador de posición para la entrada.

- **error**: boolean - Si se debe aplicar el estilo de error al TextInput. Valor por defecto: false.

- **onChangeText**: Function - Callback que se llama cuando cambia el texto de la entrada.

- **selectionColor**: string - Color de selección de la entrada. En iOS, establece tanto el color de selección como el color del cursor. En Android, solo establece el color de selección.

- **cursorColor**: string - (Solo Android) Color del cursor de la entrada.

- **underlineColor**: string - Color del subrayado inactivo de la entrada.

- **activeUnderlineColor**: string - Color del subrayado activo de la entrada.

- **outlineColor**: string - Color del contorno inactivo de la entrada.

- **activeOutlineColor**: string - Color del contorno activo de la entrada.

- **textColor**: string - Color del texto en la entrada.

- **dense**: boolean - Establece la altura mínima con diseño denso. Valor por defecto: false.

- **multiline**: boolean - Si la entrada puede tener múltiples líneas. Valor por defecto: false.

- **numberOfLines**: number - (Solo Android) Número de líneas a mostrar en la entrada.

- **onFocus**: (args: any) => void - Callback que se llama cuando la entrada de texto recibe el foco.

- **onBlur**: (args: any) => void - Callback que se llama cuando la entrada de texto pierde el foco.

- **render**: (props: RenderProps) => React.ReactNode - Callback para renderizar un componente de entrada personalizado.

- **value**: string - Valor de la entrada de texto.

- **style**: StyleProp<TextStyle> - Estilo personalizado para el TextInput.

- **theme**: ThemeProp - Tema para aplicar al componente.

- **testID**: string - ID de prueba utilizado con fines de testing.

- **contentStyle**: StyleProp<TextStyle> - Estilo personalizado para el contenido de la entrada.

- **outlineStyle**: StyleProp<ViewStyle> - Estilo personalizado para el contorno.

- **underlineStyle**: StyleProp<ViewStyle> - Estilo personalizado para el subrayado.

- **editable**: boolean - Si la entrada es editable. Valor por defecto: true.

### TextInput.Affix

Un componente para renderizar texto inicial/final en el TextInput.

#### Uso

```jsx
import * as React from "react";
import { TextInput } from "react-native-paper";

const MyComponent = () => {
  const [text, setText] = React.useState("");

  return (
    <TextInput
      mode="outlined"
      label="Outlined input"
      placeholder="Type something"
      right={<TextInput.Affix text="/100" />}
    />
  );
};
```

#### Propiedades

- **text** (requerido): string - Texto a mostrar.

- **onLayout**: (event: LayoutChangeEvent) => void - Función que se ejecuta al cambiar el layout.

- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar.

- **accessibilityLabel**: string - Etiqueta de accesibilidad para el afijo. Valor por defecto: text.

- **textStyle**: StyleProp<TextStyle> - Estilo personalizado para el elemento Text.

- **theme**: ThemeProp - Tema para aplicar al componente.

### TextInput.Icon

Un componente para renderizar un icono inicial/final en el TextInput.

#### Uso

```jsx
import * as React from "react";
import { TextInput } from "react-native-paper";

const MyComponent = () => {
  const [text, setText] = React.useState("");

  return (
    <TextInput
      label="Password"
      secureTextEntry
      right={<TextInput.Icon icon="eye" />}
    />
  );
};
```

#### Propiedades

- **icon** (requerido): IconSource - Icono a mostrar. Renombrado de 'name' a 'icon' en v5.x.

- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar.

- **forceTextInputFocus**: boolean - Si el TextInput recibirá el foco después de onPress. Valor por defecto: true.

- **color**: ((isTextInputFocused: boolean) => string | undefined) | string - Color del icono o función que recibe un booleano indicando si el TextInput está enfocado y devuelve el color.

- **rippleColor**: ColorValue - Color del efecto de ondulación.

- **style**: StyleProp<ViewStyle> - Estilo personalizado para el icono.

- **theme**: ThemeProp - Tema para aplicar al componente.

### ToggleButton

Los botones de alternancia (Toggle buttons) se pueden usar para agrupar opciones relacionadas. Para enfatizar grupos de botones de alternancia relacionados, un grupo debe compartir un contenedor común.

#### Uso

```jsx
import * as React from "react";
import { ToggleButton } from "react-native-paper";

const ToggleButtonExample = () => {
  const [status, setStatus] = React.useState("checked");

  const onButtonToggle = (value) => {
    setStatus(status === "checked" ? "unchecked" : "checked");
  };

  return (
    <ToggleButton
      icon="bluetooth"
      value="bluetooth"
      status={status}
      onPress={onButtonToggle}
    />
  );
};
```

#### Propiedades

- **icon** (requerido): IconSource - Icono a mostrar en el ToggleButton.

- **size**: number - Tamaño del icono.

- **iconColor**: string - Color de texto personalizado para el botón.

- **rippleColor**: ColorValue - Color del efecto de ondulación.

- **disabled**: boolean - Determina si el botón está deshabilitado.

- **accessibilityLabel**: string - Etiqueta de accesibilidad para el ToggleButton. Esto es leído por el lector de pantalla cuando el usuario toca el botón.

- **onPress**: (value?: GestureResponderEvent | string) => void - Función a ejecutar al presionar.

- **value**: string - Valor del botón.

- **status**: 'checked' | 'unchecked' - Estado del botón.

- **style**: Animated.WithAnimatedValue<StyleProp<ViewStyle>> - Estilo personalizado para el botón.

- **theme**: ThemeProp - Tema para aplicar al componente.

- **ref**: React.RefObject<View> - Referencia para el componente.

- **testID**: string - ID de prueba utilizado con fines de testing.

### ToggleButton.Group

ToggleButton.Group permite controlar un grupo de botones de alternancia. No cambia la apariencia de los botones de alternancia. Si deseas agruparlos en una fila, consulta ToggleButton.Row.

#### Uso

```jsx
import * as React from "react";
import { ToggleButton } from "react-native-paper";

const MyComponent = () => {
  const [value, setValue] = React.useState("left");

  return (
    <ToggleButton.Group
      onValueChange={(value) => setValue(value)}
      value={value}
    >
      <ToggleButton icon="format-align-left" value="left" />
      <ToggleButton icon="format-align-right" value="right" />
    </ToggleButton.Group>
  );
};
```

#### Propiedades

- **onValueChange** (requerido): (value: Value) => void - Función a ejecutar cuando cambia la selección.

- **value** (requerido): Value | null - Valor del botón de alternancia actualmente seleccionado.

- **children** (requerido): React.ReactNode - Elementos React que contienen botones de alternancia.

### ToggleButton.Row

ToggleButton.Row renderiza un grupo de botones de alternancia en una fila.

#### Uso

```jsx
import * as React from "react";
import { ToggleButton } from "react-native-paper";

const MyComponent = () => {
  const [value, setValue] = React.useState("left");

  return (
    <ToggleButton.Row onValueChange={(value) => setValue(value)} value={value}>
      <ToggleButton icon="format-align-left" value="left" />
      <ToggleButton icon="format-align-right" value="right" />
    </ToggleButton.Row>
  );
};
```

#### Propiedades

- **onValueChange** (requerido): (value: string) => void - Función a ejecutar cuando cambia la selección.

- **value** (requerido): string - Valor del botón de alternancia actualmente seleccionado.

- **children** (requerido): React.ReactNode - Elementos React que contienen botones de alternancia.

- **style**: StyleProp<ViewStyle> - Estilo personalizado para la fila.

### Tooltip

Los Tooltips muestran texto informativo cuando los usuarios pasan el cursor por encima, se enfocan o tocan un elemento.

Los tooltips simples, cuando se activan, muestran una etiqueta de texto que identifica un elemento, como una descripción de su función. Los tooltips deben incluir solo texto descriptivo corto y evitar repetir el texto visible de la UI.

#### Uso

```jsx
import * as React from "react";
import { IconButton, Tooltip } from "react-native-paper";

const MyComponent = () => (
  <Tooltip title="Selected Camera">
    <IconButton icon="camera" selected size={24} onPress={() => {}} />
  </Tooltip>
);
```

#### Propiedades

- **children** (requerido): React.ReactElement - Elemento de referencia del Tooltip. Necesita poder mantener una referencia.

- **enterTouchDelay**: number - El número de milisegundos que un usuario debe tocar el elemento antes de mostrar el tooltip. Valor por defecto: 500.

- **leaveTouchDelay**: number - El número de milisegundos después de que el usuario deja de tocar un elemento antes de ocultar el tooltip. Valor por defecto: 1500.

- **title** (requerido): string - Título del tooltip.

- **titleMaxFontSizeMultiplier**: number - Especifica la escala más grande posible que puede alcanzar la fuente del título.

- **theme**: ThemeProp - Tema para aplicar al componente.

### TouchableRipple

Un contenedor para vistas que deben responder a toques. Proporciona un efecto de interacción de "ondulación de tinta" material para plataformas compatibles (>= Android Lollipop). En plataformas no compatibles, se recurre a un efecto de resaltado.

#### Uso

```jsx
import * as React from "react";
import { View } from "react-native";
import { Text, TouchableRipple } from "react-native-paper";

const MyComponent = () => (
  <TouchableRipple
    onPress={() => console.log("Pressed")}
    rippleColor="rgba(0, 0, 0, .32)"
  >
    <Text>Press anywhere</Text>
  </TouchableRipple>
);
```

#### Propiedades

- **...Pressable props** - Extiende todas las propiedades del componente Pressable.

- **borderless**: boolean - Determina si se debe renderizar el efecto de ondulación fuera de los límites de la vista. Valor por defecto: false.

- **background**: Object - Tipo de fondo drawable para mostrar el feedback (Android). https://reactnative.dev/docs/pressable#rippleconfig

- **centered**: boolean - Determina si el efecto de ondulación debe comenzar desde el centro (Web).

- **disabled**: boolean - Determina si se debe prevenir la interacción con el touchable.

- **onPress**: (e: GestureResponderEvent) => void - Función a ejecutar al presionar. Si no se establece, causará que el touchable se deshabilite.

- **onLongPress**: (e: GestureResponderEvent) => void - Función a ejecutar al mantener presionado.

- **onPressIn**: (e: GestureResponderEvent) => void - Función a ejecutar inmediatamente cuando se inicia un toque, antes de onPressOut y onPress.

- **onPressOut**: (e: GestureResponderEvent) => void - Función a ejecutar cuando se libera un toque.

- **rippleColor**: ColorValue - Color del efecto de ondulación (Android >= 5.0 y Web).

- **underlayColor**: string - Color del subrayado para el efecto de resaltado (Android < 5.0 e iOS).

- **children** (requerido): ((state: PressableStateCallbackType) => React.ReactNode) | React.ReactNode - Contenido del TouchableRipple.

- **style**: StyleProp<ViewStyle> | ((state: PressableStateCallbackType) => StyleProp<ViewStyle>) | undefined - Estilo personalizado para el componente.

- **theme**: ThemeProp - Tema para aplicar al componente.

## Guía de Implementación

### Instalación

Para instalar React Native Paper en tu proyecto, ejecuta uno de los siguientes comandos dependiendo de tu gestor de paquetes:

```bash
npm install react-native-paper
```

o

```bash
yarn add react-native-paper
```

React Native Paper tiene dependencias que requieren instalación adicional:

```bash
npm install react-native-vector-icons
```

Para proyectos que utilizan Expo, puedes simplemente instalar:

```bash
expo install react-native-paper
```

### Configuración básica

Para utilizar React Native Paper en tu aplicación, debes envolver tu componente raíz con el proveedor `PaperProvider`:

```jsx
import * as React from "react";
import { Provider as PaperProvider } from "react-native-paper";
import App from "./src/App";

export default function Main() {
  return (
    <PaperProvider>
      <App />
    </PaperProvider>
  );
}
```

### Configuración de iconos

React Native Paper utiliza `react-native-vector-icons` para mostrar iconos. Necesitas configurar los iconos según la plataforma:

#### Para proyectos React Native CLI:

**Android**: Edita `android/app/build.gradle`:

```gradle
apply from: "../../node_modules/react-native-vector-icons/fonts.gradle"
```

**iOS**: Edita `ios/Podfile` y ejecuta `pod install`:

```ruby
pod 'RNVectorIcons', :path => '../node_modules/react-native-vector-icons'
```

#### Para proyectos Expo:

No se requiere configuración adicional, ya que Expo incluye los iconos por defecto.

### Tema

React Native Paper proporciona un sistema de temas completo que te permite personalizar la apariencia de tu aplicación.

#### Tema básico

```jsx
import * as React from "react";
import { Provider as PaperProvider, DefaultTheme } from "react-native-paper";

const theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    primary: "#3498db",
    accent: "#f1c40f",
  },
};

export default function Main() {
  return (
    <PaperProvider theme={theme}>
      <App />
    </PaperProvider>
  );
}
```

#### Tema oscuro

```jsx
import * as React from "react";
import { Provider as PaperProvider, DarkTheme } from "react-native-paper";

export default function Main() {
  return (
    <PaperProvider theme={DarkTheme}>
      <App />
    </PaperProvider>
  );
}
```

#### Cambio dinámico de tema

```jsx
import * as React from "react";
import {
  Provider as PaperProvider,
  DefaultTheme,
  DarkTheme,
} from "react-native-paper";
import { useColorScheme } from "react-native";

export default function Main() {
  const colorScheme = useColorScheme();
  const theme = colorScheme === "dark" ? DarkTheme : DefaultTheme;

  return (
    <PaperProvider theme={theme}>
      <App />
    </PaperProvider>
  );
}
```

### Ejemplos de Uso Común

#### Formulario de inicio de sesión

```jsx
import * as React from "react";
import { View, StyleSheet } from "react-native";
import { TextInput, Button, HelperText } from "react-native-paper";

const LoginForm = () => {
  const [email, setEmail] = React.useState("");
  const [password, setPassword] = React.useState("");
  const [secureTextEntry, setSecureTextEntry] = React.useState(true);

  const hasErrors = () => {
    return !email.includes("@");
  };

  return (
    <View style={styles.container}>
      <TextInput
        label="Email"
        value={email}
        onChangeText={(text) => setEmail(text)}
        style={styles.input}
        mode="outlined"
      />
      <HelperText type="error" visible={hasErrors()}>
        Email address is invalid!
      </HelperText>

      <TextInput
        label="Password"
        value={password}
        onChangeText={(text) => setPassword(text)}
        secureTextEntry={secureTextEntry}
        right={
          <TextInput.Icon
            icon={secureTextEntry ? "eye" : "eye-off"}
            onPress={() => setSecureTextEntry(!secureTextEntry)}
          />
        }
        style={styles.input}
        mode="outlined"
      />

      <Button
        mode="contained"
        onPress={() => console.log("Login")}
        style={styles.button}
      >
        Login
      </Button>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
  },
  input: {
    marginBottom: 8,
  },
  button: {
    marginTop: 16,
  },
});
```

#### Lista de elementos con acciones

```jsx
import * as React from "react";
import { View, StyleSheet, FlatList } from "react-native";
import { List, Divider, FAB } from "react-native-paper";

const data = [
  { id: "1", title: "Item 1", description: "Description for Item 1" },
  { id: "2", title: "Item 2", description: "Description for Item 2" },
  { id: "3", title: "Item 3", description: "Description for Item 3" },
];

const ItemList = () => {
  const renderItem = ({ item }) => (
    <List.Item
      title={item.title}
      description={item.description}
      left={(props) => <List.Icon {...props} icon="folder" />}
      right={(props) => <List.Icon {...props} icon="dots-vertical" />}
      onPress={() => console.log("Pressed", item.id)}
    />
  );

  return (
    <View style={styles.container}>
      <FlatList
        data={data}
        renderItem={renderItem}
        keyExtractor={(item) => item.id}
        ItemSeparatorComponent={() => <Divider />}
      />
      <FAB
        style={styles.fab}
        icon="plus"
        onPress={() => console.log("Add new item")}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  fab: {
    position: "absolute",
    margin: 16,
    right: 0,
    bottom: 0,
  },
});
```

================
File: docs/zustand-dev-guide.md
================
# Guía Detallada de Desarrollo con Zustand

Zustand es una solución de gestión de estado pequeña, rápida y escalable para React y aplicaciones JavaScript. Ofrece una API cómoda basada en hooks, sin ser excesivamente opinativa ni requerir mucho boilerplate.

## 1. Introducción y Ventajas

*   **Simple y Mínimo:** API fácil de aprender y usar.
*   **Rápido y Escalable:** Optimizado para el rendimiento.
*   **Basado en Hooks:** Integración natural con React.
*   **Soluciona Problemas Comunes:** Aborda problemas como el "zombie child", concurrencia de React y pérdida de contexto.
*   **Flexible:** Permite almacenar cualquier tipo de dato (primitivos, objetos, funciones).

## 2. Instalación

Instala Zustand usando tu gestor de paquetes preferido:

```bash
# NPM
npm install zustand
# Yarn
yarn add zustand
# pnpm
pnpm add zustand
```

## 3. Creación del Store

El corazón de Zustand es el "store", que se crea usando la función `create`.

### 3.1. Sintaxis Básica (JavaScript)

```javascript
import { create } from 'zustand'

const useBearStore = create((set) => ({
  bears: 0, // Estado inicial
  // Acción para incrementar
  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
  // Acción para resetear
  removeAllBears: () => set({ bears: 0 }),
  // Acción para actualizar a un valor específico
  updateBears: (newBears) => set({ bears: newBears }),
}))
```

*   `create` recibe una función (`stateCreatorFn`) que define el estado inicial y las acciones.
*   Esta función recibe `set` como argumento principal, que se usa para actualizar el estado.
*   Por defecto, `set` realiza un *merge superficial* del estado. Si pasas `{ bears: 5 }`, solo la propiedad `bears` se actualizará, manteniendo el resto del estado intacto.

### 3.2. Sintaxis con TypeScript

Para usar TypeScript, necesitas especificar el tipo del estado usando `create<T>()(...)`:

```typescript
import { create } from 'zustand'

interface BearState {
  bears: number
  increase: (by: number) => void
  removeAllBears: () => void // Añadido para consistencia
  updateBears: (newBears: number) => void // Añadido para consistencia
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
  removeAllBears: () => set({ bears: 0 }),
  updateBears: (newBears) => set({ bears: newBears }),
}))
```

*   Define una interfaz (`BearState` en este caso) para tu estado y acciones.
*   Usa `create<BearState>()(...)` para anotar el tipo.

### 3.3. La Función `set`

*   **Merge Superficial (por defecto):** `set({ a: 1 })` actualiza solo `a`, manteniendo otras propiedades.
*   **Función de Actualización:** `set((state) => ({ count: state.count + 1 }))` es la forma recomendada para actualizar basándose en el estado previo. Garantiza que trabajas con el estado más reciente, especialmente útil para actualizaciones rápidas o asíncronas.
*   **Reemplazo Completo:** `set({ a: 1 }, true)` reemplaza *todo* el estado con `{ a: 1 }`. Úsalo con precaución.

### 3.4. La Función `get`

Dentro del `stateCreatorFn`, también recibes `get` para acceder al estado actual sin necesidad de suscripción. Útil dentro de las acciones.

```typescript
const useBearStore = create<BearState>()((set, get) => ({
  // ... estado ...
  bears: 0, // Asegúrate de que el estado esté definido
  logBears: () => {
    const currentBears = get().bears;
    console.log(`Current bears: ${currentBears}`);
  },
  increase: (by) => set((state) => ({ bears: state.bears + by })),
  removeAllBears: () => set({ bears: 0 }),
  updateBears: (newBears) => set({ bears: newBears }),
  // ... otras acciones ...
}))
```

## 4. Uso del Store en Componentes React

El store creado es un hook de React.

### 4.1. Acceso Completo al Estado

```jsx
import useBearStore from './stores/bearStore'; // Asumiendo que el store está en este archivo

function BearCounter() {
  // Accede a todo el estado. Re-renderiza si CUALQUIER parte del estado cambia.
  const state = useBearStore();
  return <h1>{state.bears} bears around here...</h1>
}

function Controls() {
  const increasePopulation = useBearStore((state) => state.increase); // Corregido: usa la acción definida
  const removeAllBears = useBearStore((state) => state.removeAllBears);

  return (
    <>
      <button onClick={() => increasePopulation(1)}>one up</button> {/* Llama con el argumento 'by' */}
      <button onClick={removeAllBears}>remove all</button>
    </>
  );
}
```

### 4.2. Selectores para Optimización

Para evitar re-renders innecesarios, usa selectores. El componente solo se volverá a renderizar si el valor seleccionado cambia.

```jsx
function BearCounter() {
  // Selecciona solo 'bears'. Re-renderiza SOLO si 'bears' cambia.
  const bears = useBearStore((state) => state.bears);
  return <h1>{bears} bears around here...</h1>
}

function Controls() {
  // Selecciona solo la acción. Las acciones no cambian, por lo que esto no causa re-renders.
  const increasePopulation = useBearStore((state) => state.increase); // Corregido: usa la acción definida
  return <button onClick={() => increasePopulation(1)}>one up</button>; {/* Llama con el argumento 'by' */}
}
```

*   **Regla General:** Selecciona solo lo que el componente necesita.
*   **Selección de Múltiples Valores:** Si necesitas varios valores, puedes devolver un objeto. Sin embargo, esto puede causar re-renders si el objeto se crea nuevo en cada render. Usa `shallow` para comparar superficialmente el objeto devuelto:

```jsx
import { shallow } from 'zustand/shallow' // O 'zustand/shallow/index.js'

// Asumiendo que BearState tiene una propiedad 'name'
// interface BearState {
//   bears: number;
//   name: string; // Ejemplo
//   increase: (by: number) => void;
//   removeAllBears: () => void;
//   updateBears: (newBears: number) => void;
// }

function BearInfo() {
  const { bears, name } = useBearStore(
    (state) => ({ bears: state.bears, name: state.name }),
    shallow // Compara superficialmente {bears, name}
  );
  // ... usa bears y name ...
  return <div>{name} has {bears} bears.</div>
}
```

## 5. Actualización Detallada del Estado

### 5.1. Inmutabilidad

Zustand (y React en general) se basa en la inmutabilidad. **Nunca modifiques el estado directamente.** Siempre crea nuevos objetos o arrays al actualizar.

### 5.2. Actualización Basada en Estado Anterior

Usa siempre la forma funcional de `set` cuando la nueva actualización dependa del valor anterior:

```typescript
// Correcto
increase: (by) => set((state) => ({ bears: state.bears + by })),

// Incorrecto (puede llevar a race conditions si se llama rápido)
// increase: (by) => set({ bears: get().bears + by }),
```

### 5.3. Actualización de Objetos

Crea un nuevo objeto, copiando las propiedades existentes que no cambian.

```typescript
interface PositionState {
  position: { x: number; y: number };
  setPosition: (newPos: { x: number; y: number }) => void;
  moveX: (delta: number) => void;
}

const usePositionStore = create<PositionState>()((set) => ({
  position: { x: 0, y: 0 },
  setPosition: (newPos) => set({ position: newPos }), // Crea un nuevo objeto 'position'
  moveX: (delta) => set((state) => ({
    position: { ...state.position, x: state.position.x + delta } // Copia 'y', actualiza 'x'
  })),
}));
```

### 5.4. Actualización de Arrays

Crea un nuevo array usando métodos inmutables (`map`, `filter`, `slice`, `concat`, spread `...`). Evita métodos mutables (`push`, `splice`, `sort` in-place).

```typescript
interface TodosState {
  todos: { id: number; text: string; completed: boolean }[];
  addTodo: (text: string) => void;
  toggleTodo: (id: number) => void;
}

const useTodosStore = create<TodosState>()((set) => ({
  todos: [],
  addTodo: (text) => set((state) => ({
    todos: [...state.todos, { id: Date.now(), text, completed: false }] // Nuevo array con spread
  })),
  toggleTodo: (id) => set((state) => ({
    todos: state.todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo // Nuevo array con map
    )
  })),
}));
```

## 6. Middlewares

Los middlewares extienden la funcionalidad de Zustand envolviendo el `stateCreatorFn`.

### 6.1. `devtools`

Integra tu store con las Redux DevTools Extension para depuración.

```typescript
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'

interface BearState { // Reutilizando la interfaz anterior
  bears: number
  increase: (by: number) => void
  removeAllBears: () => void
  updateBears: (newBears: number) => void
}

const useBearStore = create<BearState>()(
  devtools( // Envuelve el state creator
    (set) => ({
      bears: 0,
      increase: (by) => set((state) => ({ bears: state.bears + by }), false, 'increaseBears'), // Opcional: nombre de acción
      removeAllBears: () => set({ bears: 0 }, false, 'removeAllBears'),
      updateBears: (newBears) => set({ bears: newBears }, false, 'updateBears'),
    }),
    { name: 'BearStore' } // Opcional: nombre para las DevTools
  )
)
```
*   **Importante:** Coloca `devtools` lo más afuera posible (último middleware en aplicar) para que capture correctamente las acciones de otros middlewares.

### 6.2. `persist`

Persiste el estado del store en `localStorage` (o `AsyncStorage` en React Native, u otro storage).

```typescript
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

interface BearState { // Reutilizando la interfaz anterior
  bears: number
  increase: (by: number) => void
  removeAllBears: () => void
  updateBears: (newBears: number) => void
}

const useBearStore = create<BearState>()(
  persist(
    (set, get) => ({ // 'get' también está disponible aquí
      bears: 0,
      increase: (by) => set({ bears: get().bears + by }),
      removeAllBears: () => set({ bears: 0 }),
      updateBears: (newBears) => set({ bears: newBears }),
    }),
    {
      name: 'food-storage', // Clave en localStorage
      storage: createJSONStorage(() => sessionStorage), // Opcional: usa sessionStorage
      // partialize: (state) => ({ bears: state.bears }), // Opcional: persistir solo 'bears'
    }
  )
)
```

### 6.3. `immer`

Permite escribir código de actualización "mutable" que Immer convierte en inmutable bajo el capó.

```typescript
import { create } from 'zustand'
import { immer } from 'zustand/middleware/immer' // Nota la ruta

interface State {
  nested: { count: number };
  incrementNested: () => void;
}

const useStore = create<State>()(
  immer((set) => ({
    nested: { count: 0 },
    incrementNested: () => set((state) => {
      state.nested.count++; // ¡Modificación directa permitida por Immer!
    }),
  }))
)
```

### 6.4. Combinando Middlewares

Simplemente anídalos:

```typescript
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { persist, createJSONStorage } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

interface BearState { // Reutilizando la interfaz anterior
  bears: number
  increase: (by: number) => void
  removeAllBears: () => void
  updateBears: (newBears: number) => void
}

const useBearStore = create<BearState>()(
  devtools( // Más externo
    persist( // Intermedio
      immer( // Más interno
        (set) => ({
          bears: 0,
          // Acciones pueden ser mutables aquí gracias a immer
          increase: (by) => set((state) => { state.bears += by; }),
          removeAllBears: () => set((state) => { state.bears = 0; }),
          updateBears: (newBears) => set((state) => { state.bears = newBears; }),
        })
      ),
      {
        name: 'bear-storage',
        storage: createJSONStorage(() => localStorage), // Ejemplo con localStorage
      }
    ),
    { name: 'BearStore-DevTools' }
  )
)
```

## 7. Patrones Avanzados

### 7.1. Slices Pattern

Organiza stores complejos dividiéndolos en "slices" (partes) que se combinan al final. Cada slice define una porción del estado y sus acciones relacionadas.

```typescript
import { create, StateCreator } from 'zustand'

// Slice 1: Bears
interface BearSlice {
  bears: number;
  addBear: () => void;
}
// El tipo StateCreator<...> necesita el estado completo (BearSlice & FishSlice)
// y opcionalmente los mutators de middleware si se usan.
// El último argumento genérico es el tipo del slice actual.
const createBearSlice: StateCreator<BearSlice & FishSlice, [], [], BearSlice> = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
});

// Slice 2: Fishes
interface FishSlice {
  fishes: number;
  addFish: () => void;
}
const createFishSlice: StateCreator<BearSlice & FishSlice, [], [], FishSlice> = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
});

// Store combinado
const useBoundStore = create<BearSlice & FishSlice>()((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
}));

// Uso
function FishCounter() {
  const fishes = useBoundStore((state) => state.fishes);
  const addFish = useBoundStore((state) => state.addFish);
  return <button onClick={addFish}>Add Fish ({fishes})</button>;
}
function BearCounter() {
  const bears = useBoundStore((state) => state.bears);
  const addBear = useBoundStore((state) => state.addBear);
  return <button onClick={addBear}>Add Bear ({bears})</button>;
}
```
*   El `StateCreator` necesita tipos adicionales para funcionar correctamente con slices y middlewares. Consulta la documentación de TypeScript de Zustand para detalles (`Mutators`).

### 7.2. Stores Vanilla (sin React)

Puedes crear stores que funcionen fuera de React usando `createStore` de `zustand/vanilla`.

```typescript
import { createStore } from 'zustand/vanilla'

interface CountState {
  count: number;
  increment: () => void;
}

const vanillaStore = createStore<CountState>()((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

const { getState, setState, subscribe } = vanillaStore;

setState({ count: 1 });
const currentState = getState(); // { count: 1, increment: [Function] }

const unsubscribe = subscribe((newState) => {
  console.log('State changed:', newState);
});

// Para usarlo en React:
import { useStore } from 'zustand'

function VanillaCounter() {
  const count = useStore(vanillaStore, (state) => state.count);
  const increment = useStore(vanillaStore, (state) => state.increment);
  return <button onClick={increment}>Vanilla Count: {count}</button>;
}
```

### 7.3. Stores con Scope (Context API)

Para tener instancias independientes de un store (por ejemplo, un store por cada item de una lista), combina Zustand con React Context.

```jsx
import React, { createContext, useContext, useRef } from 'react'; // No se necesita useState aquí
import { createStore, useStore, StoreApi } from 'zustand'; // Importa StoreApi

// 1. Define el tipo de store y la función creadora
interface CounterState {
  count: number;
  increment: () => void;
}
// Define el tipo explícito para el store vanilla
type CounterStore = StoreApi<CounterState>;

const createCounterStore = () => createStore<CounterState>()((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

// 2. Crea el Context (tipado correctamente)
const CounterContext = createContext<CounterStore | null>(null);

// 3. Crea el Provider
function CounterProvider({ children }) {
  const storeRef = useRef<CounterStore>(); // Usa el tipo CounterStore
  if (!storeRef.current) {
    storeRef.current = createCounterStore();
  }
  return (
    <CounterContext.Provider value={storeRef.current}>
      {children}
    </CounterContext.Provider>
  );
}

// 4. Crea un hook custom para usar el store del contexto
function useCounterContext<T>(selector: (state: CounterState) => T): T {
  const store = useContext(CounterContext);
  if (!store) {
    throw new Error('Missing CounterProvider');
  }
  // useStore funciona directamente con la StoreApi
  return useStore(store, selector);
}

// 5. Uso
function ScopedCounter() {
  const count = useCounterContext((state) => state.count);
  const increment = useCounterContext((state) => state.increment);
  return <button onClick={increment}>Scoped Count: {count}</button>;
}

// App.jsx
function App() {
  return (
    <div>
      <CounterProvider>
        <ScopedCounter /> {/* Instancia 1 */}
      </CounterProvider>
      <CounterProvider>
        <ScopedCounter /> {/* Instancia 2 */}
      </CounterProvider>
    </div>
  );
}
```

## 8. TypeScript Avanzado

*   **`combine`:** Middleware útil para inferir el tipo del estado inicial, evitando la necesidad de `create<T>()(...)` en casos simples.

    ```typescript
    import { create } from 'zustand'
    import { combine } from 'zustand/middleware'

    const useCombinedStore = create(
      combine({ bears: 0 }, (set) => ({ // Infiere {bears: number} como estado inicial
        // Las acciones se definen en el segundo argumento
        increase: (by: number) => set((state) => ({ bears: state.bears + by })),
      }))
    )
    // El tipo final del store es { bears: number, increase: (by: number) => void }
    ```
*   **`ExtractState`:** Helper para obtener el tipo del estado de un store inferido (útil con `combine`).
    ```typescript
    import { ExtractState } from 'zustand'
    type CombinedState = ExtractState<typeof useCombinedStore>;
    // CombinedState es { bears: number, increase: (by: number) => void }
    ```
*   **Tipado de Middlewares:** Requiere entender los `StoreMutatorIdentifier` y `Mutate`. Consulta la documentación oficial para ejemplos detallados si creas tus propios middlewares complejos.

## 9. Buenas Prácticas

*   **Inmutabilidad:** Esencial. Nunca mutes el estado directamente, excepto dentro de `immer`.
*   **Selectores:** Úsalos siempre para optimizar rendimiento. Selecciona solo los datos necesarios. Usa `shallow` para selectores que devuelven objetos/arrays no primitivos.
*   **Acciones Colocadas:** Generalmente es más simple y cohesivo mantener las acciones dentro del `create`.
*   **Stores Pequeños:** Prefiere varios stores pequeños y enfocados en lugar de un único store monolítico gigante (aunque Zustand lo maneja bien). Usa el patrón de slices si un store crece mucho.
*   **Nombres Claros:** Usa nombres descriptivos para stores, estados y acciones.

Esta guía cubre los aspectos fundamentales y algunos patrones avanzados para trabajar eficazmente con Zustand. ¡Experimenta y consulta la documentación oficial para profundizar más!

================
File: eas.json
================
{
  "cli": {
    "version": ">= 15.0.10",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

================
File: expo-audio.md
================
# Expo Audio (`expo-audio`)

Una biblioteca que proporciona una API para implementar la reproducción y grabación de audio en aplicaciones.

**Nota:** Esta página documenta una próxima versión de la biblioteca de audio. Expo Audio se encuentra actualmente en fase alfa y está sujeto a cambios importantes.

`expo-audio` es una biblioteca de audio multiplataforma para acceder a las capacidades de audio nativas del dispositivo.

Tenga en cuenta que el audio se detiene automáticamente si se desconectan los auriculares/dispositivos de audio bluetooth.

## Instalación

```bash
npx expo install expo-audio
```

Si está instalando esto en una aplicación React Native existente, asegúrese de instalar `expo` en tu proyecto.

## Configuración en la configuración de la aplicación

Puede configurar `expo-audio` usando su complemento de configuración incorporado si usa complementos de configuración en su proyecto (EAS Build o `npx expo run:[android|ios]`). El complemento le permite configurar varias propiedades que no se pueden establecer en tiempo de ejecución y requieren la creación de un nuevo binario de aplicación para que surta efecto. Si la aplicación no usa EAS Build, tendrás que configurar manualmente el paquete.

### Ejemplo `app.json` con el plugin config

```json
{
  "expo": {
    "plugins": [
      [
        "expo-audio",
        {
          "microphonePermission": "Allow $(PRODUCT_NAME) to access your microphone."
        }
      ]
    ]
  }
}
```

### Propiedades configurables

| Nombre               | Predeterminado                                       | Descripción                                                              | Plataforma |
| -------------------- | ---------------------------------------------------- | ------------------------------------------------------------------------ | ---------- |
| `microphonePermission` | `"Allow $(PRODUCT_NAME) to access your microphone"` | Una cadena para establecer el mensaje de permiso `NSMicrophoneUsageDescription`. | iOS        |

## Uso

### Reproducción de sonidos

```javascript
// Abrir en Bocadillo

import { useEffect, useState } from 'react';
import { View, StyleSheet, Button } from 'react-native';
import { useAudioPlayer } from 'expo-audio';

const audioSource = require('./assets/Hello.mp3'); // Asegúrate de tener este archivo o reemplázalo

export default function App() {
  const player = useAudioPlayer(audioSource);

  return (
    <View style={styles.container}>
      <Button title="Play Sound" onPress={() => player.play()} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    backgroundColor: '#ecf0f1',
    padding: 10,
  },
});
```

### Grabación de sonidos

```javascript
// Abrir en Bocadillo

import { useState, useEffect } from 'react'; // Añadido useEffect
import { View, StyleSheet, Button, Alert } from 'react-native'; // Añadido Alert
import { useAudioRecorder, RecordingOptions, AudioModule, RecordingPresets } from 'expo-audio';

export default function App() {
  const audioRecorder = useAudioRecorder(RecordingPresets.HIGH_QUALITY);

  const record = async () => {
    try { // Añadido try-catch para manejo de errores
        await audioRecorder.prepareToRecordAsync();
        audioRecorder.record();
    } catch (error) {
        console.error("Failed to start recording", error);
        Alert.alert('Error', 'Failed to start recording');
    }
  };

  const stopRecording = async () => {
    try { // Añadido try-catch
        // The recording will be available on `audioRecorder.uri`.
        await audioRecorder.stop();
        if (audioRecorder.uri) {
            console.log('Recording stopped and stored at', audioRecorder.uri);
            // Aquí puedes hacer algo con la grabación, como reproducirla o subirla
        }
    } catch (error) {
        console.error("Failed to stop recording", error);
        Alert.alert('Error', 'Failed to stop recording');
    }
  };

  useEffect(() => {
    (async () => {
      const status = await AudioModule.requestRecordingPermissionsAsync();
      if (!status.granted) {
        Alert.alert('Permission Error', 'Permission to access microphone was denied'); // Mensaje más claro
      }
    })();
  }, []);

  return (
    <View style={styles.container}>
      <Button
        title={audioRecorder.isRecording ? 'Stop Recording' : 'Start Recording'}
        onPress={audioRecorder.isRecording ? stopRecording : record}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    backgroundColor: '#ecf0f1',
    padding: 10,
  },
});
```

### Reproducción o grabación de audio en segundo plano (iOS)

En iOS, la reproducción de audio y la grabación en segundo plano solo están disponibles en aplicaciones independientes y requieren una configuración adicional. Cada característica en segundo plano requiere una clave especial (`UIBackgroundModes`) en la matriz del archivo `Info.plist`. En las aplicaciones independientes, esta matriz está vacía de forma predeterminada, por lo que para usar las funciones en segundo plano, deberá agregar las claves adecuadas a su configuración `app.json`.

Vea un ejemplo de `app.json` que habilita la reproducción de audio en segundo plano:

```json
{
  "expo": {
    // ...
    "ios": {
      // ...
      "infoPlist": {
        // ...
        "UIBackgroundModes": [
          "audio"
        ]
      }
    }
  }
}
```

### Notas sobre el uso de la web

*   Un problema de `MediaRecorder` en Chrome produce archivos WebM a los que les faltan los metadatos de duración. Consulte el [problema abierto de Chromium](https://bugs.chromium.org/p/chromium/issues/detail?id=642012).
*   Las opciones de codificación de `MediaRecorder` y otras configuraciones son inconsistentes en todos los navegadores. El uso de un Polyfill como [kbumsik/opus-media-recorder](https://github.com/kbumsik/opus-media-recorder) o [ai/audio-recorder-polyfill](https://github.com/ai/audio-recorder-polyfill) en su aplicación mejorará su experiencia. Cualquier opción que se pase a `prepareToRecordAsync` se pasará directamente a la API de `MediaRecorder` y, como tal, al polyfill.
*   Los navegadores web requieren que los sitios se sirvan de forma segura (HTTPS) para que puedan escuchar un micrófono. Ver [Seguridad de MediaDevices.getUserMedia()](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#security) para más detalles.

## API

```javascript
import { useAudioPlayer, useAudioRecorder, AudioModule, RecordingPresets /* ...otros */ } from 'expo-audio';
```

### Constantes

*   **`Audio.AUDIO_SAMPLE_UPDATE`**
    *   Tipo: `'audioSampleUpdate'`
*   **`Audio.PLAYBACK_STATUS_UPDATE`**
    *   Tipo: `'playbackStatusUpdate'`
*   **`Audio.RECORDING_STATUS_UPDATE`**
    *   Tipo: `'recordingStatusUpdate'`
*   **`Audio.RecordingPresets`**
    *   Tipo: `Record<string, RecordingOptions>`
    *   Constante que contiene definiciones de los dos ejemplos preestablecidos de `RecordingOptions`, tal como se implementan en el SDK de audio.
    *   **`HIGH_QUALITY`**:
        ```javascript
        RecordingPresets.HIGH_QUALITY = {
          extension: '.m4a',
          sampleRate: 44100,
          numberOfChannels: 2,
          bitRate: 128000,
          android: {
            outputFormat: 'mpeg4',
            audioEncoder: 'aac',
          },
          ios: {
            outputFormat: IOSOutputFormat.MPEG4AAC, // Asumiendo que IOSOutputFormat está definido
            audioQuality: AudioQuality.MAX, // Asumiendo que AudioQuality está definido
            linearPCMBitDepth: 16,
            linearPCMIsBigEndian: false,
            linearPCMIsFloat: false,
          },
          web: {
            mimeType: 'audio/webm',
            bitsPerSecond: 128000,
          },
        };
        ```
    *   **`LOW_QUALITY`**:
        ```javascript
        RecordingPresets.LOW_QUALITY = {
          extension: '.m4a',
          sampleRate: 44100,
          numberOfChannels: 2,
          bitRate: 64000,
          android: {
            extension: '.3gp',
            outputFormat: '3gp',
            audioEncoder: 'amr_nb',
          },
          ios: {
            audioQuality: AudioQuality.MIN, // Asumiendo que AudioQuality está definido
            outputFormat: IOSOutputFormat.MPEG4AAC, // Asumiendo que IOSOutputFormat está definido
            linearPCMBitDepth: 16,
            linearPCMIsBigEndian: false,
            linearPCMIsFloat: false,
          },
          web: {
            mimeType: 'audio/webm',
            bitsPerSecond: 128000, // Nota: Este valor parece alto para LOW_QUALITY en web, podría ser un error tipográfico en la fuente original.
          },
        };
        ```

### Ganchos (Hooks)

*   **`useAudioPlayer(source?, updateInterval?)`**
    *   `source` (Opcional): `number | AudioSource`
    *   `updateInterval` (Opcional): `number`
    *   **Devuelve**: `AudioPlayer`
*   **`useAudioPlayerStatus(player)`**
    *   `player`: `AudioPlayer`
    *   **Devuelve**: `AudioStatus`
*   **`useAudioRecorder(options, statusListener?)`**
    *   `options`: `RecordingOptions`
    *   `statusListener` (Opcional): `(status: RecordingStatus) => void`
    *   **Devuelve**: `AudioRecorder`
*   **`useAudioRecorderState(recorder, interval?)`**
    *   `recorder`: `AudioRecorder`
    *   `interval` (Opcional): `number`
    *   **Devuelve**: `RecorderState`
*   **`useAudioSampleListener(player, listener)`**
    *   `player`: `AudioPlayer`
    *   `listener`: `(data: AudioSample) => void`
    *   **Devuelve**: `void`

### Clases

#### `AudioPlayer`

*   Tipo: `class extends SharedObject<AudioEvents>` (Asumiendo `SharedObject`)

##### Propiedades de `AudioPlayer`

*   `currentTime`: `number` - La posición actual a través del elemento de audio, en segundos.
*   `duration`: `number` - La duración total del audio en segundos.
*   `id`: `number` - Identificador único para el objeto player.
*   `isAudioSamplingSupported`: `boolean` - Valor booleano que indica si el muestreo de audio es compatible con la plataforma.
*   `isBuffering`: `boolean` - Valor booleano que indica si el reproductor está almacenando en búfer.
*   `isLoaded`: `boolean` - Valor booleano que indica si el reproductor ha terminado de cargarse.
*   `loop`: `boolean` - Valor booleano que indica si el reproductor está en bucle actualmente.
*   `muted`: `boolean` - Valor booleano que indica si el reproductor está silenciado actualmente.
*   `paused`: `boolean` - Valor booleano que indica si el reproductor está actualmente en pausa.
*   `playbackRate`: `number` - La velocidad de reproducción actual del audio.
*   `playing`: `boolean` - Valor booleano que indica si el jugador está jugando actualmente.
*   `shouldCorrectPitch`: `boolean` - Un booleano que describe si estamos corrigiendo el tono para una tasa cambiada.
*   `volume`: `number` - El volumen actual del audio.

##### Métodos de `AudioPlayer`

*   **`pause()`**: Pausa el reproductor.
    *   Devuelve: `void`
*   **`play()`**: Empieza a reproducir audio.
    *   Devuelve: `void`
*   **`remove()`**: Elimine el reproductor de la memoria para liberar recursos.
    *   Devuelve: `void`
*   **`replace(source)`**: Reemplaza la fuente de audio actual por una nueva.
    *   `source`: `AudioSource`
    *   Devuelve: `void`
*   **`seekTo(seconds)`**: Busca la reproducción por el número de segundos dado.
    *   `seconds`: `number` - El número de segundos por los que se va a buscar.
    *   Devuelve: `Promise<void>`
*   **`setPlaybackRate(rate, pitchCorrectionQuality?)`**: Establece la velocidad de reproducción actual del audio.
    *   `rate`: `number` - La velocidad de reproducción del audio.
    *   `pitchCorrectionQuality` (Opcional): `PitchCorrectionQuality` - La calidad de la corrección del tono.
    *   Devuelve: `void`

#### `AudioRecorder`

*   Tipo: `class extends SharedObject<RecordingEvents>` (Asumiendo `SharedObject`)

##### Propiedades de `AudioRecorder`

*   `currentTime`: `number` - La duración actual de la grabación, en segundos.
*   `id`: `number` - Identificador único para el objeto registrador.
*   `isRecording`: `boolean` - Valor booleano que indica si la grabación está en curso.
*   `uri`: `null | string` - El uri de la grabación.

##### Métodos de `AudioRecorder`

*   **`getAvailableInputs()`**: Devuelve una lista de las entradas de grabación disponibles. Este método solo se puede llamar si `Recording` ha sido preparado.
    *   Devuelve: `Promise<RecordingInput[]>` - Una `Promise` que se cumple con una matriz de objetos `RecordingInput`.
*   **`getCurrentInput()`**: Devuelve la entrada de grabación seleccionada actualmente. Este método solo se puede llamar si `Recording` ha sido preparado.
    *   Devuelve: `Promise<RecordingInput>` - Una `Promise` que se cumple con un objeto `RecordingInput`.
*   **`getStatus()`**: Estado de la grabación actual.
    *   Devuelve: `RecorderState`
*   **`pause()`**: Pausa la grabación.
    *   Devuelve: `void`
*   **`prepareToRecordAsync(options?)`**: Prepara la grabación para la grabación.
    *   `options` (Opcional): `Partial<RecordingOptions>`
    *   Devuelve: `Promise<void>`
*   **`record()`**: Inicia la grabación.
    *   Devuelve: `void`
*   **`recordForDuration(seconds)`**: Detiene la grabación una vez transcurrido el tiempo especificado.
    *   `seconds`: `number` - El tiempo en segundos para detener la grabación.
    *   Devuelve: `void`
*   **`setInput(inputUid)`**: Establece la entrada de grabación actual.
    *   `inputUid`: `string` - El uid de un `RecordingInput`.
    *   Devuelve: `Promise<void>` - Una `Promise` que se resuelve si se realiza correctamente o se rechaza si no lo es.
*   **`startRecordingAtTime(seconds)`**: Inicia la grabación a la hora indicada.
    *   `seconds`: `number` - El tiempo en segundos para comenzar a grabar.
    *   Devuelve: `void`
*   **`stop()`**: Detenga la grabación.
    *   Devuelve: `Promise<void>`

### Métodos (Módulo `Audio`)

*   **`Audio.getRecordingPermissionsAsync()`**
    *   Devuelve: `Promise<PermissionResponse>`
*   **`Audio.requestRecordingPermissionsAsync()`**
    *   Devuelve: `Promise<PermissionResponse>`
*   **`Audio.setAudioModeAsync(mode)`**
    *   `mode`: `Partial<AudioMode>`
    *   Devuelve: `Promise<void>`
*   **`Audio.setIsAudioActiveAsync(active)`**
    *   `active`: `boolean`
    *   Devuelve: `Promise<void>`

### Suscripciones a eventos

*   **`Audio.useAudioSampleListener(player, listener)`** (Nota: Este parece ser un Hook, no un método estático de `Audio`. Verificar la fuente original si es posible. Lo listamos aquí como en la fuente.)
    *   `player`: `AudioPlayer`
    *   `listener`: `(data: AudioSample) => void`
    *   Devuelve: `void`

### Interfaces

*   **`PermissionResponse`**: Objeto obtenido por las funciones de permisos `get` y `request`.
    *   `canAskAgain`: `boolean` - Indica si se puede volver a solicitar al usuario un permiso específico.
    *   `expires`: `PermissionExpiration` - Determina la hora en que caduca el permiso.
    *   `granted`: `boolean` - Indica si se concede el permiso.
    *   `status`: `PermissionStatus` - Determina el estado del permiso.

### Tipos

*   **`AndroidAudioEncoder`**: `'default' | 'amr_nb' | 'amr_wb' | 'aac' | 'he_aac' | 'aac_eld'`
*   **`AndroidOutputFormat`**: `'default' | '3gp' | 'mpeg4' | 'amrnb' | 'amrwb' | 'aac_adts' | 'mpeg2ts' | 'webm'`
*   **`AudioEvents`**:
    *   `audioSampleUpdate`: `(data: AudioSample) => void`
    *   `playbackStatusUpdate`: `(status: AudioStatus) => void`
*   **`AudioMode`**:
    *   `allowsRecording`: `boolean`
    *   `interruptionMode`: `InterruptionMode`
    *   `playsInSilentMode`: `boolean`
    *   `shouldPlayInBackground`: `boolean`
    *   `shouldRouteThroughEarpiece`: `boolean`
*   **`AudioSample`**:
    *   `channels`: `AudioSampleChannel[]`
    *   `timestamp`: `number`
*   **`AudioSampleChannel`**:
    *   `frames`: `number[]`
*   **`AudioSource`**: `string | null | number | { uri?: string; headers?: Record<string, string> }`
    *   `headers` (Opcional): `Record<string, string>` - Cabeceras HTTP para fuentes remotas. Requiere `Access-Control-Allow-Origin` en web.
    *   `uri` (Opcional): `string` - URI del audio (HTTPS, local, recurso estático).
*   **`AudioStatus`**:
    *   `currentTime`: `number`
    *   `duration`: `number`
    *   `id`: `number`
    *   `isBuffering`: `boolean`
    *   `isLoaded`: `boolean`
    *   `loop`: `boolean`
    *   `muted`: `boolean`
    *   `playbackRate`: `number`
    *   `playbackState`: `string` // Podría ser un enum más específico
    *   `playing`: `boolean`
    *   `reasonForWaitingToPlay`: `string` // Podría ser un enum
    *   `shouldCorrectPitch`: `boolean`
    *   `timeControlStatus`: `string` // Podría ser un enum
*   **`BitRateStrategy`**: `'constant' | 'longTermAverage' | 'variableConstrained' | 'variable'`
*   **`InterruptionMode`**: `'mixWithOthers' | 'doNotMix' | 'duckOthers'`
*   **`PermissionExpiration`**: `'never' | number` - Actualmente siempre `'never'`.
*   **`PitchCorrectionQuality`**: `'low' | 'medium' | 'high'`
*   **`RecorderState`**:
    *   `canRecord`: `boolean`
    *   `durationMillis`: `number`
    *   `isRecording`: `boolean`
    *   `mediaServicesDidReset`: `boolean`
    *   `metering` (Opcional): `number`
    *   `url`: `string | null`
*   **`RecordingEvents`**:
    *   `recordingStatusUpdate`: `(status: RecordingStatus) => void`
*   **`RecordingInput`**:
    *   `name`: `string`
    *   `type`: `string`
    *   `uid`: `string`
*   **`RecordingOptions`**:
    *   `android`: `RecordingOptionsAndroid`
    *   `bitRate`: `number` (Ej: `128000`)
    *   `extension`: `string` (Ej: `.caf`)
    *   `ios`: `RecordingOptionsIos`
    *   `numberOfChannels`: `number` (Ej: `2`)
    *   `sampleRate`: `number` (Ej: `44100`)
    *   `web` (Opcional): `RecordingOptionsWeb`
*   **`RecordingOptionsAndroid`**:
    *   `audioEncoder`: `AndroidAudioEncoder`
    *   `extension` (Opcional): `string` (Ej: `.caf`)
    *   `maxFileSize` (Opcional): `number` (Bytes, Ej: `65536`)
    *   `outputFormat`: `AndroidOutputFormat`
    *   `sampleRate` (Opcional): `number` (Ej: `44100`)
*   **`RecordingOptionsIos`**:
    *   `audioQuality`: `AudioQuality | number`
    *   `bitDepthHint` (Opcional): `number` (Ej: `16`)
    *   `bitRateStrategy` (Opcional): `BitRateStrategy | number` // Tipo corregido
    *   `extension` (Opcional): `string` (Ej: `.caf`)
    *   `linearPCMBitDepth` (Opcional): `number` (Ej: `16`)
    *   `linearPCMIsBigEndian` (Opcional): `boolean`
    *   `linearPCMIsFloat` (Opcional): `boolean`
    *   `outputFormat` (Opcional): `string | IOSOutputFormat | number`
    *   `sampleRate` (Opcional): `number` (Ej: `44100`)
*   **`RecordingOptionsWeb`**:
    *   `bitsPerSecond` (Opcional): `number`
    *   `mimeType` (Opcional): `string`
*   **`RecordingStatus`**:
    *   `error`: `string | null`
    *   `hasError`: `boolean`
    *   `id`: `number`
    *   `isFinished`: `boolean`
    *   `url`: `string | null`

### Enumeraciones

*   **`AudioQuality`** (iOS)
    *   `MIN = 0`
    *   `LOW = 32`
    *   `MEDIUM = 64`
    *   `HIGH = 96`
    *   `MAX = 127`
*   **`IOSOutputFormat`** (iOS)
    *   `MPEGLAYER1 = ".mp1"`
    *   `MPEGLAYER2 = ".mp2"`
    *   `MPEGLAYER3 = ".mp3"`
    *   `MPEG4AAC = "aac "` // Nota: el espacio es intencional según algunas APIs de Apple
    *   `MPEG4AAC_ELD = "aace"`
    *   `MPEG4AAC_ELD_SBR = "aacf"`
    *   `MPEG4AAC_ELD_V2 = "aacg"`
    *   `MPEG4AAC_HE = "aach"`
    *   `MPEG4AAC_LD = "aacl"`
    *   `MPEG4AAC_HE_V2 = "aacp"`
    *   `MPEG4AAC_SPATIAL = "aacs"`
    *   `AC3 = "ac-3"`
    *   `AES3 = "aes3"`
    *   `APPLELOSSLESS = "alac"`
    *   `ALAW = "alaw"`
    *   `AUDIBLE = "AUDB"`
    *   `60958AC3 = "cac3"`
    *   `MPEG4CELP = "celp"`
    *   `ENHANCEDAC3 = "ec-3"`
    *   `MPEG4HVXC = "hvxc"`
    *   `ILBC = "ilbc"`
    *   `APPLEIMA4 = "ima4"`
    *   `LINEARPCM = "lpcm"`
    *   `MACE3 = "MAC3"`
    *   `MACE6 = "MAC6"`
    *   `AMR = "samr"`
    *   `AMR_WB = "sawb"`
    *   `DVIINTELIMA = 1836253201` // 'ima4' como entero
    *   `MICROSOFTGSM = 1836253233` // 'gsm ' como entero
    *   `QUALCOMM = "Qclp"`
    *   `QDESIGN2 = "QDM2"`
    *   `QDESIGN = "QDMC"`
    *   `MPEG4TWINVQ = "twvq"`
    *   `ULAW = "ulaw"`
*   **`PermissionStatus`**
    *   `DENIED = "denied"`: El usuario ha denegado el permiso.
    *   `GRANTED = "granted"`: El usuario ha concedido el permiso.
    *   `UNDETERMINED = "undetermined"`: El usuario aún no ha concedido o denegado el permiso.

================
File: index.ts
================
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "moduleResolution": "bundler" // Añadido para resolver tipos de navegación
  }
}

================
File: app.json
================
{
  "expo": {
    "name": "pizza",
    "slug": "pizza",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.viefmoon.pizza"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "extra": {
      "eas": {
        "projectId": "0eb3c4d0-a8be-4327-9313-be8b3b1038b3"
      }
    }
  }
}

================
File: .cursor/rules/expo.mdc
================
---
description: 
globs: 
alwaysApply: true
---
# Guía de Estilo y Convenciones del Proyecto (ClearByte) (ANDROID)

Este documento describe las convenciones de codificación, arquitectura y uso de librerías para el desarrollo de la aplicación móvil ClearByte para restaurantes, utilizando Expo, React Native y TypeScript. **La aplicación soportará tanto un tema claro como uno oscuro**, adaptándose a las preferencias del sistema y permitiendo la selección manual por parte del usuario. Se han integrado descripciones detalladas de las dependencias clave para clarificar su propósito y uso específico en el proyecto.

## Filosofía General

Eres un experto/a en TypeScript, React Native, Expo y desarrollo de UI móvil. Priorizamos código limpio, mantenible, performante y una excelente experiencia de usuario, aprovechando las herramientas seleccionadas y ofreciendo una interfaz adaptable a temas claro y oscuro.

---

## 1. Estilo y Estructura del Código

*   **Concisión y Claridad:** Escribe código `TypeScript` técnico, conciso y bien documentado donde sea necesario. Usa ejemplos precisos si creas utilidades reutilizables.
*   **Programación Funcional:** Utiliza patrones de programación funcional y declarativa. **Evita las clases** de JavaScript/TypeScript en favor de funciones y hooks.
*   **Modularidad (DRY):** Prefiere la iteración y la modularización sobre la duplicación de código. Crea componentes y hooks reutilizables.
*   **Nombres Descriptivos:** Usa nombres de variables descriptivos, a menudo con verbos auxiliares (ej., `isLoadingOrders`, `hasPrinterConnectionError`, `isMenuModalVisible`, `isDarkModeEnabled`).
*   **Estructura de Archivos:** Organiza los archivos lógicamente:
    *   `src/`
        *   `components/`: Componentes UI reutilizables (ej., `styled-button`, `order-card`).
        *   `constants/`: Valores fijos y reutilizables (ej., claves de AsyncStorage, nombres de eventos, roles fijos, URLs).
        *   `screens/`: Componentes que representan pantallas completas (ej., `OrderListScreen`, `MenuManagementScreen`).
        *   `navigation/`: Configuración de `react-navigation` (Stacks, Drawer, tipos).
        *   `hooks/`: Hooks personalizados (ej., `usePrinter`, `useAuth`, `useAppTheme`).
        *   `services/`: Lógica de comunicación API (`apisauce` setup, funciones de servicio específicas por recurso).
        *   `store/`: Configuración y slices de `zustand` (ej., `authStore`, `printerStore`, **`themeStore`**).
        *   `lib/`: Utilidades generales (ej., configuración de `date-fns`, helpers).
        *   `styles/`: **Configuración de temas (claro/oscuro), definición de paletas de colores (`colors.ts`), tipografía (`typography.ts`) y configuración/exportación de temas de Paper (`theme.ts`).**
        *   `types/`: Definiciones globales de TypeScript, interfaces y tipos generados por `zod` (incluyendo `ThemePreference`).
        *   `assets/`: Fuentes, imágenes estáticas, archivos Lottie JSON.

---

## 2. Convenciones de Nomenclatura

*   **Directorios:** Minúsculas con guiones (kebab-case) (ej., `components/order-details`, `screens/auth-wizard`).
*   **Archivos (Componentes):** Mayúsculas CamelCase (PascalCase) (ej., `OrderCard.tsx`, `PrimaryButton.tsx`).
*   **Archivos (Otros):** Minúsculas camelCase (ej., `apiClient.ts`, `useAuth.ts`, `printerStore.ts`, **`themeStore.ts`**, **`appTheme.ts`**).
*   **Exportaciones:** Prefiere exportaciones nombradas (`named exports`) para componentes y utilidades.

---

## 3. Uso de TypeScript

*   **Obligatorio:** Usa `TypeScript` para *todo* el código.
*   **Interfaces sobre Tipos:** Prefiere `interface` para definir la forma de objetos y props; usa `type` para uniones, intersecciones, tipos de preferencia (como el tema) o tipos más complejos.
    ```typescript
    // En src/types/theme.ts o similar
    export type ThemePreference = 'light' | 'dark' | 'system';
    ```
*   **Evitar Enums:** No uses `enum` de TypeScript. Usa objetos `as const` o mapas simples en su lugar para mejor legibilidad y tree-shaking.
    ```typescript
    // Preferido
    export const OrderStatus = {
      PENDING: 'pending',
      CONFIRMED: 'confirmed',
      READY: 'ready',
    } as const;
    export type OrderStatusValue = typeof OrderStatus[keyof typeof OrderStatus];
    ```
*   **Componentes Funcionales:** Usa componentes funcionales con props tipadas mediante interfaces.
    ```typescript
    interface OrderCardProps {
      orderId: string;
      // ... otras props
    }
    export function OrderCard({ orderId }: OrderCardProps): JSX.Element {
      // ...
    }
    ```
*   **Modo Estricto:** Habilita `strict: true` en `tsconfig.json` para máxima seguridad de tipos.
*   **Validación con `zod`:**
    *   **Uso Principal:** `zod` es nuestra librería estándar para declarar esquemas y validar datos. Fundamental para la robustez de la aplicación.
    *   **Definición:** Define esquemas `zod` para todas las estructuras de datos clave (modelos de API, formularios, etc.). Colócalos en `src/types` o cerca de su uso.
    *   **Validación:** Utilízalo para validar datos de formularios (integrado con `react-hook-form` vía `@hookform/resolvers`) y, opcionalmente, para validar respuestas de API y asegurar que cumplen el contrato.
    *   **Inferencia de Tipos:** Infiere tipos de TypeScript a partir de esquemas `zod` (`z.infer<typeof schema>`) para mantener la coherencia y evitar duplicación.
    ```typescript
    import { z } from 'zod';

    // Define la "forma" esperada de un item de menú
    export const menuItemSchema = z.object({
      id: z.string().uuid(),
      name: z.string().min(1, "El nombre es obligatorio"),
      price: z.number().positive("El precio debe ser positivo"),
      description: z.string().optional(),
      imageUrl: z.string().url().optional(),
    });

    // Infiere el tipo TypeScript desde el esquema Zod
    export type MenuItem = z.infer<typeof menuItemSchema>;
    ```

---

## 4. Sintaxis y Formato

*   **Palabra Clave `function`:** Usa la palabra clave `` `function` `` para funciones puras y componentes React para una mejor identificación y hoisting. Usa funciones flecha para callbacks y funciones que dependen del contexto léxico.
*   **Concisión:** Evita llaves (`{}`) innecesarias en condicionales/JSX para declaraciones simples.
*   **JSX Declarativo:** Escribe JSX de forma clara y declarativa. Evita lógica compleja directamente en el JSX; extráela a variables o funciones helper.
*   **Prettier:** Usa `Prettier` con una configuración estándar definida en el proyecto para formateo automático y consistente. Asegúrate de que esté integrado en tu editor y en hooks de pre-commit.

---

## 5. UI y Estilos

*   **Librería de Componentes: `react-native-paper`**
    *   **Uso Principal:** Es la base de nuestra UI. Utiliza sus componentes (`Button`, `Card`, `TextInput`, `DataTable`, `Modal`, `Appbar`, etc.) para construir interfaces de forma rápida y consistente, siguiendo las directrices de Material Design 3 (MD3).
    *   **Theming:** **Fundamental para el soporte de temas claro/oscuro.**
        *   Define paletas de colores específicas para los temas claro y oscuro en `src/styles/colors.ts`.
        *   Configura y extiende los temas base de Paper (`MD3LightTheme`, `MD3DarkTheme`) en `src/styles/theme.ts`, aplicando tus paletas de colores y definiendo tipografía personalizada si es necesario.
        *   Envuelve la aplicación raíz con `PaperProvider` y proporciónale el tema *activo* (determinado por la preferencia del sistema/usuario, gestionado por `zustand`).
*   **Iconos: `@expo/vector-icons`**
    *   **Uso Principal:** Proporciona un amplio catálogo de iconos vectoriales (`MaterialIcons`, `FontAwesome`, `Ionicons`, etc.) integrados fácilmente con `react-native-paper` (ej., `Button icon="add"`).
    *   **Aplicación Específica:** Indispensables para botones, navegación, indicadores visuales (estado de pedidos), iconos junto a elementos de menú, etc. **Asegúrate de que los iconos elegidos y sus colores (a menudo heredados del texto/botón) funcionen bien visualmente en ambos temas (claro y oscuro).**
*   **Layout:** Usa `Flexbox` para el posicionamiento y diseño. `react-native-paper` ya lo utiliza internamente.
*   **Diseño Adaptable:** Usa `useWindowDimensions` de React Native si necesitas ajustes específicos basados en el tamaño de la pantalla (poco común en apps de POS, pero posible para tablas densas).
*   **Modo Claro/Oscuro:**
    *   **Detección del Sistema:** Usa el hook `useColorScheme` de `react-native` para detectar la preferencia del sistema operativo ('light', 'dark', o `null`/`undefined`).
    *   **Preferencia de Usuario:** Implementa una opción en la configuración de la app para que el usuario elija explícitamente entre 'Claro', 'Oscuro' o 'Automático/Sistema' (`ThemePreference`).
    *   **Persistencia:** Guarda la preferencia del usuario (`ThemePreference`) en `@react-native-async-storage/async-storage`.
    *   **Estado Global:** Gestiona la preferencia seleccionada y el tema *activo* resultante (el objeto de tema de Paper completo) en un store de `zustand` (`themeStore`). Un hook `useAppTheme` puede exponer el tema activo y la función para cambiar la preferencia.
    *   **Aplicación de Estilos:**
        *   **Obtener el Tema:** Dentro de los componentes funcionales, obtén el objeto de tema actual con el hook `useTheme` de `react-native-paper`.
        *   **Referenciar Colores y Estilos del Tema:** Al definir estilos (preferiblemente usando `StyleSheet.create` fuera del render o memoizado), **SIEMPRE** referencia los valores del objeto `theme` obtenido (ej., `color: theme.colors.primary`, `backgroundColor: theme.colors.background`, `fontSize: theme.fonts.bodyLarge.fontSize`, `margin: theme.spacing?.m` si defines espaciado).
        *   **EVITAR COLORES HARDCODEADOS:** **Nunca uses valores de color literales como `'#FFFFFF'`, `'#000000'`, `'black'`, `'white'` directamente en los estilos de los componentes.** Utiliza siempre las referencias del tema (`theme.colors.*`).
        *   **Estilos Condicionales Mínimos:** Si excepcionalmente necesitas estilos muy específicos que no se cubren solo con los colores/fuentes del tema, puedes verificar `theme.dark` (booleano) dentro de tu lógica de estilos, pero intenta minimizar esto prefiriendo definir colores semánticos adecuados en el tema.
    ```typescript
    // Ejemplo en un componente (MyComponent.tsx)
    import React from 'react';
    import { View, StyleSheet } from 'react-native';
    import { useTheme, Text, Surface } from 'react-native-paper';

    export function MyComponent(): JSX.Element {
      const theme = useTheme(); // Obtiene el tema activo (claro u oscuro) de PaperProvider

      // Los estilos se definen usando el tema. Se puede memoizar si es necesario.
      // Es común definir esta función fuera del componente o usar useMemo si el tema cambia raramente.
      const styles = React.useMemo(() => StyleSheet.create({
        container: {
          backgroundColor: theme.colors.surface, // Color de fondo adaptable
          padding: 16, // O usa theme.spacing.m si lo defines
          borderRadius: theme.roundness * 2, // Usa valores del tema
        },
        title: {
          color: theme.colors.primary, // Color primario adaptable
          // Usa tipos de fuente definidos en el tema si los configuras
          ...theme.fonts?.titleLarge, // Ejemplo si usas fuentes de Paper
          marginBottom: 8,
        },
        text: {
          color: theme.colors.onSurface, // Color de texto sobre superficie adaptable
          ...theme.fonts?.bodyMedium,
        }
      }), [theme]); // Se recalcula solo si el objeto 'theme' cambia

      return (
        // Surface ya aplica colores de superficie y elevación del tema
        <Surface style={styles.container} elevation={1}>
          <Text style={styles.title}>Título Adaptable al Tema</Text>
          <Text style={styles.text}>
            Este texto y el fondo cambian de color automáticamente
            cuando el usuario cambia el tema claro/oscuro.
          </Text>
        </Surface>
      );
    }
    ```
*   **Accesibilidad (a11y):** Asegura la accesibilidad:
    *   Usa props como `accessibilityLabel`, `accessibilityHint`, `accessibilityRole`. `react-native-paper` ya proporciona buenos defaults.
    *   **Considera el Contraste:** Al definir los temas claro/oscuro, asegúrate de que los ratios de contraste entre texto y fondo cumplan las directrices de accesibilidad (WCAG AA).
    *   Testea con lectores de pantalla (VoiceOver, TalkBack) en ambos modos.
*   **Animaciones:**
    *   **Navegación/Gestos:** `react-native-reanimated` y `react-native-gesture-handler` son dependencias clave, requeridas por `react-navigation` y `react-native-paper`. Aseguran transiciones de pantalla y gestos suaves (ej., apertura del Drawer, swipes). `react-native-reanimated` ejecuta animaciones en el hilo nativo para máximo rendimiento.
    *   **UX Mejorada:** Usa `lottie-react-native` para renderizar animaciones Lottie (JSON desde After Effects). Ideal para indicadores de carga atractivos, animaciones de éxito (pedido confirmado), o feedback visual sutil. **Asegúrate de que las animaciones Lottie funcionen bien con ambos fondos de tema o diséñalas para que sean independientes del fondo.**

---

## 6. Gestión del Área Segura (Safe Area)

*   **Proveedor Global:** Envuelve toda la aplicación (usualmente en `App.tsx`, dentro del `PaperProvider`) con `SafeAreaProvider` de `react-native-safe-area-context`.
*   **Uso en Pantallas:** Utiliza el componente `SafeAreaView` de `react-native-safe-area-context` como contenedor principal en cada *pantalla* para evitar solapamientos con notches, barras de estado y barras de navegación del sistema. No añadas paddings manuales para este propósito. `SafeAreaView` se asegura de que el contenido importante sea visible.

---

## 7. Optimización del Rendimiento

*   **Gestión de Estado del Servidor: `@tanstack/react-query` (React Query)**
    *   **Obligatorio:** Usar React Query para *toda* la interacción con la API (fetching, caching, mutations, sincronización). Es fundamental para manejar datos remotos eficientemente.
    *   **Uso:** Define `queryKey` descriptivos. Usa `useQuery` para obtener datos (ej., listas de pedidos, menú), gestionando `isLoading`/`isError`. Usa `useMutation` para CUD (ej., crear pedido, actualizar estado), implementando `onSuccess` para invalidar queries (`queryClient.invalidateQueries`). Confía en el caching inteligente. Considera optimistic updates para mejorar UX.
*   **Gestión de Estado Global del Cliente: `zustand`**
    *   **Uso:** Para estado que *no* proviene del servidor y necesita ser compartido globalmente o entre componentes no relacionados directamente. Simple y eficiente.
    *   **Casos de Uso:** Estado de autenticación (usuario logueado, datos del usuario), configuración global (restaurante/sucursal activa), estado de conexión/selección de la impresora Bluetooth, **preferencia de tema UI seleccionada ('light'/'dark'/'system') y el tema activo resultante de `react-native-paper`**, estado de conexión de red (`netinfo`).
    *   **Persistencia (Opcional con Middleware):** Configura `zustand` con `persist` middleware para guardar automáticamente ciertos stores (como `themeStore`, `authStore` parcialmente) en `AsyncStorage`, para que el estado se restaure al reiniciar la app.
*   **Minimizar `useState`/`useEffect`:** Prefiere derivar estado cuando sea posible. Usa React Query/Zustand para estados complejos o globales antes de recurrir a `useState` complejos o `useEffect` propensos a errores.
*   **Imágenes: `expo-image`**
    *   **Uso:** Usa el componente `<Image>` de `expo-image` en lugar del de `react-native` para mostrar imágenes (ej., fotos de platos, logos).
    *   **Beneficios:** Ofrece mejor rendimiento, caching avanzado y soporte de formatos modernos (WebP). Incluye `width` y `height` explícitos para evitar saltos de layout.
*   **Renderizados:**
    *   Usa `React.memo` para componentes que reciben props complejas y no deben re-renderizarse innecesariamente si las props no cambian (comprobación shallow).
    *   Usa `useMemo` para memoizar cálculos costosos o valores que no deben cambiar entre renders si sus dependencias no cambian (ej., estilos derivados del tema).
    *   Usa `useCallback` para memoizar funciones pasadas como props a componentes memoizados, evitando re-renders innecesarios causados por referencias de función inestables. Usa estas optimizaciones *con moderación* y solo cuando identifiques un problema de rendimiento real.
*   **Listas:** Usa `FlatList` o `SectionList` de React Native para listas largas (ej., lista de pedidos, menú), aprovechando su virtualización para optimizar el uso de memoria y rendimiento. Pasa `extraData={theme}` si los elementos de la lista dependen del tema y este puede cambiar.
*   **Inicio de App:** Usa `expo-splash-screen` para mantener la pantalla de bienvenida visible mientras se carga la app inicial y se realizan comprobaciones esenciales (ej., verificar estado de autenticación, **cargar la preferencia de tema desde AsyncStorage**, cargar configuración inicial).

---

## 8. Navegación

*   **Librería Principal: `react-navigation`**
    *   **Core:** `@react-navigation/native` es la base indispensable.
    *   **Navegador Principal:** `@react-navigation/drawer` (Menú lateral) para secciones principales (Dashboard, Pedidos, Menú, Clientes, Configuración, etc.).
    *   **Navegador Secundario:** `@react-navigation/native-stack` (Pila) *dentro* de cada sección del drawer para flujos de tareas (Lista -> Detalles -> Editar).
    *   **Theming:** Configura las opciones de los navegadores (`screenOptions`, `options`) para usar los colores del tema activo de `react-native-paper` (ej., `headerStyle: { backgroundColor: theme.colors.surface }`, `headerTintColor: theme.colors.primary`, `drawerActiveTintColor`, `drawerInactiveTintColor`, etc.).
*   **Dependencias Clave:** `react-native-screens`, `react-native-gesture-handler`, `react-native-safe-area-context`. Deben estar correctamente instaladas y configuradas.
*   **Paso de Parámetros:** Usa parámetros de ruta tipados para pasar datos entre pantallas de forma segura. Define los tipos en un archivo centralizado (ej., `src/navigation/types.ts`).
*   **Deep Linking:** Configura deep linking usando `expo-linking` si necesitas navegar a pantallas específicas desde notificaciones push o enlaces externos.

---

## 9. Comunicación con API

*   **Cliente HTTP: `apisauce`**
    *   **Propósito:** Wrapper ligero sobre `axios` para simplificar peticiones HTTP y manejo de respuestas/errores.
    *   **Configuración:** Instancia única configurada (`baseURL`, `headers` comunes, `timeout`) en `src/services/apiClient.ts`.
    *   **Funciones de Servicio:** Funciones tipadas por recurso (ej., `orderService.ts`) que usan la instancia de `apisauce`.
    *   **Llamada:** Estas funciones son usadas por React Query (`queryFn`, `mutationFn`).
    *   **Manejo de Errores:** Normaliza respuestas (`ok`, `problem`). Centralizar lógica común (ej., monitor para 401 -> logout).
*   **Orquestación y Estado del Servidor: `@tanstack/react-query`** (Ver Sección 7).

---

## 10. Manejo de Formularios

*   **Librería Principal: `react-hook-form`**
    *   **Uso:** Gestión de estado, registro (`Controller`), validación y envío de *todos* los formularios (añadir/editar plato, pedido, cliente, configuración).
    *   **Integración:** Conectar inputs de `react-native-paper` (`TextInput`, `Checkbox`, etc.) usando el componente `Controller` para manejar `onChange`, `onBlur`, `value`, `error`.
*   **Validación:**
    *   **Librería:** `zod` (Ver Sección 3).
    *   **Esquemas:** Definir esquemas `zod` claros para la estructura de datos de cada formulario.
    *   **Resolución:** Usar `@hookform/resolvers/zod` en la configuración de `useForm` para conectar los esquemas `zod`. Los errores de validación estarán disponibles en `formState.errors` y se pueden mostrar usando `HelperText` de `react-native-paper`.

---

## 11. Manejo de Errores

*   **Validación Preventiva:** Usa `zod` intensivamente para validar datos de formularios *antes* de enviarlos (ver Sección 10) y opcionalmente respuestas de API.
*   **Errores de API:**
    *   React Query (`isError`, `error` en `useQuery`/`useMutation`) para controlar el estado en la UI.
    *   `apisauce` (`problem`, `originalError`) para detalles del error.
    *   Mostrar mensajes claros y accionables al usuario. Usar componentes como `Snackbar` o `Banner` de Paper.
    *   Centralizar manejo de errores críticos (ej., 401/403 -> logout).
*   **Errores Inesperados (Runtime):** Implementa un `ErrorBoundary` global para capturar errores de renderizado y mostrar una pantalla de fallback amigable.
*   **Conectividad:** Usa `@react-native-community/netinfo`.
    *   Hook `useNetworkStatus` que proporcione estado actual.
    *   Guardar estado en `zustand` si es necesario globalmente.
    *   Mostrar indicador visual (ej., `Banner` de Paper) si está offline.
    *   Deshabilitar funcionalidades online y notificar al usuario.
*   **Logging:** Integra Sentry (`@sentry/react-native` o `sentry-expo`) para reportar errores en producción/staging.
*   **Patrones de Código:** Guard clauses, early returns para simplificar lógica y mejorar legibilidad.

---

## 12. Funcionalidades Nativas y Hardware

*   **Impresión Térmica Directa (Cocina/Recibos): `react-native-bluetooth-escpos-printer`**
    *   **Core:** Librería *esencial* para impresión directa en impresoras térmicas Bluetooth (protocolo ESC/POS).
    *   **Flujo:** Descubrir -> Conectar -> Guardar conexión (Zustand/AsyncStorage) -> Formatear datos (ESC/POS) -> Enviar comando de impresión. Manejar errores.
    *   **Abstracción:** **Muy Recomendado:** Crear un hook `useThermalPrinter` o un servicio para encapsular la complejidad.
*   **Notificaciones (Push y Locales): `expo-notifications`**
    *   **Uso Principal:** Comunicación en tiempo real y alertas.
    *   **Push (Remotas):** Configurar APN/FCM en servidor. *Crítico* para alertar sobre nuevos pedidos online.
    *   **Locales:** Programar desde la app para recordatorios, confirmaciones, etc.
    *   **Manejo:** Implementar listeners para foreground/background/killed state.
*   **Sonido de Notificación: `expo-av` (Audio/Video)**
    *   **Uso Principal:** Reproducir un sonido *distintivo* con notificaciones clave (nuevo pedido) para entornos ruidosos. Usa `expo-av` para cargar y reproducir el audio.
*   **Selección Fecha/Hora: `@react-native-community/datetimepicker`**
    *   **Uso:** Muestra el selector nativo OS para fechas/horas (pedidos programados, filtros).
*   **Selección de Imágenes (Galería/Cámara): `expo-image-picker`**
    *   **Uso:** Permite seleccionar/tomar fotos (ej., para platos del menú).
    *   **Permisos:** Solicitar permisos de Cámara y/o Galería usando los métodos del propio módulo (`requestCameraPermissionsAsync`, `requestMediaLibraryPermissionsAsync`) de forma justificada y en el momento necesario.
*   **Almacenamiento Local Simple: `@react-native-async-storage/async-storage`**
    *   **Uso:** Almacenamiento persistente asíncrono clave-valor para datos **no sensibles**.
    *   **Aplicación:** Guardar preferencias del usuario como **la preferencia de tema ('light'/'dark'/'system')**, ID de la impresora térmica predeterminada, email del último usuario (si no se considera sensible).
*   **Almacenamiento Seguro: `react-native-encrypted-storage`**
    *   **Uso:** Para almacenar datos sensibles como **tokens de autenticación (JWT refresh/access tokens)**. Utiliza Keychain (iOS) / Keystore (Android). **Preferir sobre AsyncStorage para cualquier dato sensible.**
*   **Sistema de Archivos: `expo-file-system`**
    *   **Uso:** Acceso al sistema de archivos local (leer/escribir).
    *   **Aplicación:** Guardar temporalmente archivos generados (PDFs con `expo-print`), descargar assets, caching.
*   **Impresión Estándar/PDF: `expo-print`**
    *   **Uso:** Generar PDFs desde HTML y enviarlos al sistema de impresión estándar del OS (AirPrint/Android Print Service).
    *   **Aplicación:** Para recibos/reportes en formato PDF (diferente a la impresión térmica directa).

---

## 13. Build y Desarrollo

*   **Development Builds con `expo-dev-client`:**
    *   **Obligatorio:** Necesario porque usamos librerías con código nativo no incluidas en Expo Go (ej., `react-native-bluetooth-escpos-printer`, `react-native-encrypted-storage`, `@react-native-community/*`).
    *   **Workflow:**
        1.  Crear build: `eas build --profile development --platform android/ios` o localmente `npx expo run:android`/`npx expo run:ios`.
        2.  Instalar el `.apk`/`.app` en dispositivo/emulador.
        3.  Iniciar Metro: `npx expo start --dev-client`. La app instalada se conectará, permitiendo desarrollo con Fast Refresh y acceso a todo el código nativo.
*   **EAS Build (Expo Application Services):**
    *   **Uso:** Para crear todas las builds: `development`, `preview` (QA/TestFlight/Internal), `production` (Store).
    *   **Configuración:** Definir perfiles en `eas.json` (variables de entorno, credenciales, etc.).
*   **Expo Updates (OTA Updates):**
    *   **Uso:** Implementar `expo-updates` para desplegar actualizaciones de JS y assets Over-the-Air sin pasar por revisión de tienda.
    *   **Beneficios:** Ideal para bug fixes rápidos, cambios menores de UI/lógica.
    *   **Configuración:** Configurar en `app.json`/`app.config.js` y usar EAS Update para publicar.

---

## 14. Utilidades Adicionales

*   **Fechas y Horas: `date-fns`**
    *   **Uso Estándar:** Utilizar `date-fns` para *toda* la manipulación, comparación y formateo de fechas/horas.
    *   **Beneficios:** Moderna, inmutable, tree-shakeable, API funcional clara.
    *   **Aplicación Específica:** Formateo para UI (ej., `format`, `formatDistanceToNow`), cálculos (ej., `differenceInMinutes`, `addHours`), parseo de fechas API (`parseISO`), comparaciones (`isBefore`, `isAfter`). Configurar localización (`locale: es`) donde sea necesario.

---

## 15. Seguridad

*   **Comunicación:** Forzar **HTTPS** para toda la comunicación API. Configurar en `apisauce`.
*   **Autenticación y Tokens:**
    *   Utilizar tokens JWT.
    *   **Almacenamiento Seguro:** Guardar tokens de sesión (refresh/access) usando **`react-native-encrypted-storage`**. No usar AsyncStorage para esto.
    *   Incluir token de acceso en cabecera `Authorization: Bearer <token>`. Implementar lógica de refresh de tokens.
*   **Validación de Entradas:** Usar `zod` rigurosamente para validar datos de formularios y potencialmente parámetros de ruta/API.
*   **Permisos Nativos:**
    *   Solicitar permisos just-in-time, explicando por qué son necesarios.
    *   Usar las APIs de solicitud de permisos de los módulos específicos de Expo (ej., `expo-image-picker.requestCameraPermissionsAsync()`).
    *   Manejar casos de denegación de permisos.
*   **Secretos:** **Nunca** incluir claves de API, secretos u otra información sensible directamente en el código fuente. Usar variables de entorno gestionadas a través de **EAS Secrets** y cargadas en los perfiles de build en `eas.json`.
*   **Dependencias:** Mantener dependencias actualizadas y auditar regularmente (`npm audit`/`yarn audit`) para mitigar vulnerabilidades conocidas.
*   

Dependencias [package.json](mdc:package.json)

================
File: package.json
================
{
  "name": "pizza",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.4",
    "@hookform/resolvers": "^5.0.1",
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "^8.3.0",
    "@react-native-community/netinfo": "^11.4.1",
    "@react-navigation/drawer": "^7.3.8",
    "@react-navigation/native": "^7.1.5",
    "@react-navigation/native-stack": "^7.3.9",
    "@tanstack/react-query": "^5.72.1",
    "apisauce": "^3.1.1",
    "date-fns": "^4.1.0",
    "expo": "~52.0.43",
    "expo-audio": "^0.3.5",
    "expo-dev-client": "~5.0.19",
    "expo-file-system": "~18.0.12",
    "expo-image": "~2.0.7",
    "expo-image-picker": "^16.0.6",
    "expo-notifications": "^0.29.14",
    "expo-print": "~14.0.3",
    "expo-status-bar": "~2.0.1",
    "lottie-react-native": "^7.2.2",
    "react": "18.3.1",
    "react-hook-form": "^7.55.0",
    "react-native": "0.76.9",
    "react-native-bluetooth-escpos-printer": "^0.0.5",
    "react-native-encrypted-storage": "^4.0.3",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-paper": "^5.13.1",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-url-polyfill": "^2.0.0",
    "zod": "^3.24.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@typescript-eslint/eslint-plugin": "^7.13.1",
    "@typescript-eslint/parser": "^7.13.1",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "eslint-plugin-react": "^7.34.3",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-native": "^4.1.0",
    "typescript": "^5.3.3"
  },
  "private": true
}



================================================================
End of Codebase
================================================================
