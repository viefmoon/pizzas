This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: .cursor, src
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/rules/expo.mdc
src/app/components/common/GlobalSnackbar.tsx
src/app/services/apiClient.ts
src/app/store/authStore.ts
src/app/store/snackbarStore.ts
src/app/store/themeStore.ts
src/app/styles/colors.ts
src/app/styles/theme.ts
src/app/styles/typography.ts
src/app/types/env.d.ts
src/app/types/theme.types.ts
src/modules/auth/components/LoginForm.tsx
src/modules/auth/screens/LoginScreen.tsx
src/modules/auth/services/authService.ts
src/modules/auth/types/auth.types.ts

================================================================
Files
================================================================

================
File: src/app/components/common/GlobalSnackbar.tsx
================
import React from "react";
import { StyleSheet } from "react-native";
import { Snackbar, Text } from "react-native-paper";
import {
  useSnackbarStore,
  SnackbarType,
} from "../../../app/store/snackbarStore";
import { useAppTheme } from "../../../app/styles/theme";

const GlobalSnackbar: React.FC = () => {
  const { visible, message, type, duration, hideSnackbar } = useSnackbarStore();
  const theme = useAppTheme(); // Obtiene el tema activo (light/dark)

  // Función para determinar el estilo basado en el tipo de snackbar
  const getSnackbarStyle = (snackbarType: SnackbarType) => {
    switch (snackbarType) {
      case "success":
        // Usa colores definidos en tu tema para éxito
        return { backgroundColor: theme.colors.successContainer };
      case "error":
        // Usa colores definidos en tu tema para error
        return { backgroundColor: theme.colors.errorContainer };
      case "warning":
        // Usa colores definidos en tu tema para advertencia
        return { backgroundColor: theme.colors.warningContainer };
      case "info":
        // Usa colores definidos en tu tema para información
        return { backgroundColor: theme.colors.infoContainer };
      default:
        return {};
    }
  };

  // Función para determinar el color del texto basado en el fondo para asegurar contraste
  const getSnackbarTextStyle = (snackbarType: SnackbarType) => {
    // Asegúrate de tener estos colores definidos en colors.ts y extendidos en theme.ts
    // Si no los tienes, puedes usar un color por defecto o calcular uno.
    const defaultTextColor = theme.dark
      ? theme.colors.surface
      : theme.colors.onSurface; // O theme.colors.inverseOnSurface como usa Paper por defecto

    switch (snackbarType) {
      case "success":
        // Deberías tener un color 'onSuccessContainer' en tu tema
        return { color: theme.colors.onSuccessContainer || defaultTextColor };
      case "error":
        return { color: theme.colors.onErrorContainer }; // Paper ya define onErrorContainer;
      case "warning":
        return { color: theme.colors.onWarningContainer || defaultTextColor };
      case "info":
        return { color: theme.colors.onInfoContainer || defaultTextColor };
      default:
        return { color: theme.colors.inverseOnSurface };
    }
  };

  return (
    <Snackbar
      visible={visible}
      onDismiss={hideSnackbar}
      duration={duration}
      style={[styles.snackbarBase, getSnackbarStyle(type)]}
      theme={{ roundness: theme.roundness }}
    >
      <Text style={getSnackbarTextStyle(type)}>{message}</Text>
    </Snackbar>
  );
};

const styles = StyleSheet.create({
  snackbarBase: {
    // Puedes añadir estilos base aquí si necesitas, ej: ajustar márgenes
    // position: 'absolute', // Asegúrate de que esté posicionado correctamente si es necesario
    // bottom: 0, // O donde quieras que aparezca
    // left: 0,
    // right: 0,
  },
  // No necesitas estilos de texto aquí si los aplicas dinámicamente
});

export default GlobalSnackbar;

================
File: src/app/services/apiClient.ts
================
import { create } from "apisauce";
import { API_URL } from "@env";
import EncryptedStorage from "react-native-encrypted-storage";
import { useAuthStore } from "../store/authStore";

// Define la URL base de tu API
const apiClient = create({
  baseURL: API_URL,
  headers: { "Cache-Control": "no-cache", Accept: "application/json" },
  // Puedes añadir un timeout si lo necesitas, por ejemplo 10 segundos
  // timeout: 10000,
});

// Interceptor para añadir el token de autenticación
apiClient.addAsyncRequestTransform((request) => async () => {
  try {
    const token = await EncryptedStorage.getItem("auth_token");
    if (token) {
      if (!request.headers) request.headers = {};
      request.headers["Authorization"] = `Bearer ${token}`;
    }
  } catch (error) {
    console.error("Error al recuperar el token de autenticación:", error);
  }
});

// Monitor para manejar errores de autenticación (401)
apiClient.addMonitor((response) => {
  if (response.status === 401 && !response.config?.url?.includes("/auth")) {
    console.warn("Acceso no autorizado detectado (401). Cerrando sesión...");
    // Obtener la función de logout del store y ejecutarla
    const logout = useAuthStore.getState().logout;
    if (logout) {
      logout();
    }
  }

  // Log de errores generales
  if (!response.ok) {
    console.error("Problema en la petición API:", {
      problema: response.problem,
      url: response.config?.url,
      método: response.config?.method,
      estado: response.status,
    });
  }
});

// --- Interceptores (Ejemplos Opcionales) ---

// Ejemplo: Monitor para manejar errores comunes como 401 Unauthorized
// import { tuAuthStore } from '../store/authStore'; // Asumiendo un store Zustand para auth
// apiClient.addMonitor(response => {
//   if (response.status === 401 && !response.config?.url?.includes('/login')) { // Evita bucles en login
//     console.warn('Unauthorized access detected (401). Logging out.');
//     // Llama a tu función de logout global
//     // tuAuthStore.getState().logout();
//   }
//   // Puedes añadir más monitores para otros códigos de estado o problemas
//   if (!response.ok) {
//     console.error('API Request Problem:', response.problem, response);
//   }
// });

// --- Fin Interceptores ---

export default apiClient;

================
File: src/app/store/authStore.ts
================
import { create } from "zustand";
import EncryptedStorage from "react-native-encrypted-storage";

interface AuthState {
  isAuthenticated: boolean;
  token: string | null;
  setToken: (token: string) => Promise<void>;
  logout: () => Promise<void>;
}

export const useAuthStore = create<AuthState>((set) => ({
  isAuthenticated: false,
  token: null,
  setToken: async (token: string) => {
    try {
      await EncryptedStorage.setItem("auth_token", token);
      set({ token, isAuthenticated: true });
    } catch (error) {
      console.error("Error al guardar el token:", error);
    }
  },
  logout: async () => {
    try {
      await EncryptedStorage.removeItem("auth_token");
      set({ token: null, isAuthenticated: false });
    } catch (error) {
      console.error("Error al cerrar sesión:", error);
    }
  },
}));

================
File: src/app/store/snackbarStore.ts
================
// Store para manejar el estado del Snackbar global
import { create } from "zustand";

export type SnackbarType = "info" | "success" | "error" | "warning";

interface SnackbarState {
  visible: boolean;
  message: string;
  type: SnackbarType;
  duration?: number;
  showSnackbar: (params: {
    message: string;
    type?: SnackbarType;
    duration?: number;
  }) => void;
  hideSnackbar: () => void;
}

export const useSnackbarStore = create<SnackbarState>((set) => ({
  visible: false,
  message: "",
  type: "info",
  duration: 3000,
  showSnackbar: ({ message, type = "info", duration = 3000 }) =>
    set({ visible: true, message, type, duration }),
  hideSnackbar: () => set({ visible: false }),
}));

================
File: src/app/store/themeStore.ts
================
// Store para manejar el estado del tema de la aplicación
import React from "react";
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { useColorScheme } from "react-native";

import {
  ThemePreference,
  THEME_PREFERENCE_STORAGE_KEY,
  THEME_MODE,
} from "../types/theme.types";
import { lightTheme, darkTheme } from "../styles/theme";

interface ThemeState {
  themePreference: ThemePreference;
  activeTheme: typeof lightTheme | typeof darkTheme;
  isSystemDarkMode: boolean | null;
  setThemePreference: (preference: ThemePreference) => void;
  setSystemDarkMode: (isDark: boolean | null) => void;
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set, get) => ({
      // Valor por defecto: usar el tema del sistema
      themePreference: THEME_MODE.SYSTEM,
      // Por defecto comenzamos con el tema claro hasta que detectemos la preferencia del sistema
      activeTheme: lightTheme,
      // Estado que guarda la preferencia del sistema
      isSystemDarkMode: null,

      setThemePreference: (preference: ThemePreference) => {
        const { isSystemDarkMode } = get();

        // Actualiza la preferencia del usuario
        set({ themePreference: preference });

        // Determina el tema activo basado en la nueva preferencia
        if (preference === THEME_MODE.SYSTEM) {
          // Si es 'system', usa lo que indique el sistema
          set({ activeTheme: isSystemDarkMode ? darkTheme : lightTheme });
        } else {
          // Si es 'light' o 'dark', usa el tema correspondiente
          set({
            activeTheme:
              preference === THEME_MODE.DARK ? darkTheme : lightTheme,
          });
        }
      },

      setSystemDarkMode: (isDark: boolean | null) => {
        const { themePreference } = get();

        // Actualiza el estado de la preferencia del sistema
        set({ isSystemDarkMode: isDark });

        // Si la preferencia actual es 'system', actualiza el tema activo
        if (themePreference === THEME_MODE.SYSTEM && isDark !== null) {
          set({ activeTheme: isDark ? darkTheme : lightTheme });
        }
      },
    }),
    {
      name: THEME_PREFERENCE_STORAGE_KEY,
      storage: createJSONStorage(() => AsyncStorage),
      // Solo persistimos la preferencia del usuario, no el tema activo
      partialize: (state) => ({ themePreference: state.themePreference }),
    }
  )
);

// Hook personalizado para detectar cambios en el tema del sistema y actualizarlo en el store
export function useSystemThemeDetector() {
  const systemColorScheme = useColorScheme();
  const setSystemDarkMode = useThemeStore((state) => state.setSystemDarkMode);

  React.useEffect(() => {
    // Actualiza el estado con el tema detectado del sistema (null si no se puede detectar)
    const isDarkMode = systemColorScheme === "dark";
    setSystemDarkMode(isDarkMode);
  }, [systemColorScheme, setSystemDarkMode]);
}

================
File: src/app/styles/colors.ts
================
// Define las paletas de colores para temas claro y oscuro
// Estos colores son referenciales, deben ajustarse según la identidad de marca específica

// Paleta de colores para modo claro
export const lightColors = {
  // Colores principales
  primary: "#FF5722", // Rojo-naranja, color principal para la app de pizza
  primaryContainer: "#FFDACF",
  onPrimary: "#FFFFFF",
  onPrimaryContainer: "#401400",

  // Colores secundarios
  secondary: "#775652",
  secondaryContainer: "#FFDBDB",
  onSecondary: "#FFFFFF",
  onSecondaryContainer: "#2C1512",

  // Colores de acento/terciarios
  tertiary: "#705C2E",
  tertiaryContainer: "#FBDFA6",
  onTertiary: "#FFFFFF",
  onTertiaryContainer: "#261A00",

  // Colores de fondo y superficie
  background: "#FFFBFF",
  onBackground: "#201A19",
  surface: "#FFFBFF",
  onSurface: "#201A19",
  surfaceVariant: "#F5DDD8",
  onSurfaceVariant: "#534341",

  // Colores de estado/feedback
  error: "#BA1A1A",
  errorContainer: "#FFDAD6",
  onError: "#FFFFFF",
  onErrorContainer: "#410002",

  // Elementos de UI
  outline: "#857371",
  outlineVariant: "#D8C2BE",
  inverseSurface: "#362F2E",
  inverseOnSurface: "#FBEEE9",
  inversePrimary: "#FFB59E",

  // Otros colores semánticos
  success: "#4CAF50",
  successContainer: "#CCFFE3",
  onSuccessContainer: "#00381A", // Verde oscuro para contraste en claro
  warning: "#FB8C00",
  warningContainer: "#FFEACF",
  onWarningContainer: "#3D2100", // Naranja oscuro para contraste en claro
  info: "#2196F3",
  infoContainer: "#D4E8FF",
  onInfoContainer: "#002E60", // Azul oscuro para contraste en claro
};

// Paleta de colores para modo oscuro
export const darkColors = {
  // Colores principales
  primary: "#FF7043", // Naranja más vibrante
  primaryContainer: "#662E1A",
  onPrimary: "#FFFFFF",
  onPrimaryContainer: "#FFDACF",

  // Colores secundarios
  secondary: "#FFB74D", // Naranja más claro para contraste
  secondaryContainer: "#774B1F",
  onSecondary: "#000000",
  onSecondaryContainer: "#FFE0B2",

  // Colores de acento/terciarios
  tertiary: "#FFD54F", // Amarillo cálido
  tertiaryContainer: "#775B25",
  onTertiary: "#000000",
  onTertiaryContainer: "#FFF3C4",

  // Colores de fondo y superficie
  background: "#121212", // Fondo más oscuro para mejor contraste
  onBackground: "#FFFFFF",
  surface: "#1E1E1E", // Superficie ligeramente más clara que el fondo
  onSurface: "#FFFFFF",
  surfaceVariant: "#2C2C2C",
  onSurfaceVariant: "#E0E0E0",

  // Colores de estado/feedback
  error: "#FF5252",
  errorContainer: "#8B0000",
  onError: "#FFFFFF",
  onErrorContainer: "#FFEBEE",

  // Elementos de UI
  outline: "#4F4F4F",
  outlineVariant: "#3D3D3D",
  inverseSurface: "#FFFFFF",
  inverseOnSurface: "#121212",
  inversePrimary: "#FF5722",

  // Otros colores semánticos
  success: "#69F0AE",
  successContainer: "#1B5E20",
  onSuccessContainer: "#B3FFD1", // Verde claro para contraste en oscuro
  warning: "#FFC107",
  warningContainer: "#795548",
  onWarningContainer: "#FFE0B2", // Naranja claro para contraste en oscuro
  info: "#64B5F6",
  infoContainer: "#1565C0",
  onInfoContainer: "#B3E5FC", // Azul claro para contraste en oscuro
};

================
File: src/app/styles/theme.ts
================
// Configuración y exportación de temas para react-native-paper
import { MD3LightTheme, MD3DarkTheme, useTheme } from "react-native-paper";
import type { MD3Typescale } from "react-native-paper/lib/typescript/types";
import { lightColors, darkColors } from "./colors";
import { typography } from "./typography";

// Extender el tipo MD3Colors para incluir nuestros colores personalizados
declare global {
  namespace ReactNativePaper {
    interface MD3Colors {
      success: string;
      successContainer: string;
      onSuccessContainer: string;
      warning: string;
      warningContainer: string;
      onWarningContainer: string;
      info: string;
      infoContainer: string;
      onInfoContainer: string;
    }
  }
}

// Define el espacio entre elementos UI (basado en Material Design)
const spacing = {
  xs: 4,
  s: 8,
  m: 16,
  l: 24,
  xl: 32,
  xxl: 40,
};

// Convertir nuestra tipografía a la estructura esperada por MD3Theme
const typescale: MD3Typescale = {
  default: {
    fontFamily: typography.bodyMedium.fontFamily,
    fontWeight: "normal",
    letterSpacing: typography.bodyMedium.letterSpacing,
  },
  displayLarge: { ...typography.displayLarge, fontWeight: "normal" },
  displayMedium: { ...typography.displayMedium, fontWeight: "normal" },
  displaySmall: { ...typography.displaySmall, fontWeight: "normal" },
  headlineLarge: { ...typography.headlineLarge, fontWeight: "normal" },
  headlineMedium: { ...typography.headlineMedium, fontWeight: "normal" },
  headlineSmall: { ...typography.headlineSmall, fontWeight: "normal" },
  titleLarge: { ...typography.titleLarge, fontWeight: "normal" },
  titleMedium: { ...typography.titleMedium, fontWeight: "500" },
  titleSmall: { ...typography.titleSmall, fontWeight: "500" },
  bodyLarge: { ...typography.bodyLarge, fontWeight: "normal" },
  bodyMedium: { ...typography.bodyMedium, fontWeight: "normal" },
  bodySmall: { ...typography.bodySmall, fontWeight: "normal" },
  labelLarge: { ...typography.labelLarge, fontWeight: "500" },
  labelMedium: { ...typography.labelMedium, fontWeight: "500" },
  labelSmall: { ...typography.labelSmall, fontWeight: "500" },
};

// Crea y extiende el tema claro de Paper con nuestras personalizaciones
export const lightTheme = {
  ...MD3LightTheme,
  colors: {
    ...MD3LightTheme.colors,
    ...lightColors,
  },
  fonts: typescale,
  spacing,
  // Puedes añadir más propiedades personalizadas aquí
  roundness: 8, // Radio de borde para componentes
};

// Crea y extiende el tema oscuro de Paper con nuestras personalizaciones
export const darkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...MD3DarkTheme.colors,
    ...darkColors,
  },
  fonts: typescale,
  spacing,
  // Puedes añadir más propiedades personalizadas aquí
  roundness: 8, // Radio de borde para componentes
};

// Tipo para los temas personalizados
export type AppTheme = typeof lightTheme;

// Helper para usar el tema en componentes (para tener autocompletado)
export const useAppTheme = () => useTheme() as AppTheme;

================
File: src/app/styles/typography.ts
================
// Define los estilos tipográficos según Material Design 3
// Estos valores se pueden ajustar según las necesidades específicas del diseño

import { Platform } from "react-native";

// Configuración de tipografía siguiendo Material Design 3
export const typography = {
  // Fuentes base para Android e iOS
  fonts: {
    regular: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto",
      default: "System",
    }),
    medium: Platform.select({
      ios: "SF Pro Text-Medium",
      android: "Roboto-Medium",
      default: "System-Medium",
    }),
    light: Platform.select({
      ios: "SF Pro Text-Light",
      android: "Roboto-Light",
      default: "System-Light",
    }),
    thin: Platform.select({
      ios: "SF Pro Text-Thin",
      android: "Roboto-Thin",
      default: "System-Thin",
    }),
  },

  // Estilos de texto según MD3
  displayLarge: {
    fontFamily: Platform.select({
      ios: "SF Pro Display",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 57,
    lineHeight: 64,
    letterSpacing: -0.25,
  },
  displayMedium: {
    fontFamily: Platform.select({
      ios: "SF Pro Display",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 45,
    lineHeight: 52,
    letterSpacing: 0,
  },
  displaySmall: {
    fontFamily: Platform.select({
      ios: "SF Pro Display",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 36,
    lineHeight: 44,
    letterSpacing: 0,
  },
  headlineLarge: {
    fontFamily: Platform.select({
      ios: "SF Pro Display",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 32,
    lineHeight: 40,
    letterSpacing: 0,
  },
  headlineMedium: {
    fontFamily: Platform.select({
      ios: "SF Pro Display",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 28,
    lineHeight: 36,
    letterSpacing: 0,
  },
  headlineSmall: {
    fontFamily: Platform.select({
      ios: "SF Pro Display",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 24,
    lineHeight: 32,
    letterSpacing: 0,
  },
  titleLarge: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 22,
    lineHeight: 28,
    letterSpacing: 0,
  },
  titleMedium: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto-Medium",
      default: "System-Medium",
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.15,
  },
  titleSmall: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto-Medium",
      default: "System-Medium",
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelLarge: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto-Medium",
      default: "System-Medium",
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.1,
  },
  labelMedium: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto-Medium",
      default: "System-Medium",
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  labelSmall: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto-Medium",
      default: "System-Medium",
    }),
    fontSize: 11,
    lineHeight: 16,
    letterSpacing: 0.5,
  },
  bodyLarge: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 16,
    lineHeight: 24,
    letterSpacing: 0.5,
  },
  bodyMedium: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 14,
    lineHeight: 20,
    letterSpacing: 0.25,
  },
  bodySmall: {
    fontFamily: Platform.select({
      ios: "SF Pro Text",
      android: "Roboto",
      default: "System",
    }),
    fontSize: 12,
    lineHeight: 16,
    letterSpacing: 0.4,
  },
};

// Si necesitas adaptar para Android vs iOS, puedes exportar variantes específicas:
export const iosFontFamily = {
  regular: "System",
  medium: "System",
  light: "System",
  thin: "System",
};

export const androidFontFamily = {
  regular: "sans-serif",
  medium: "sans-serif-medium",
  light: "sans-serif-light",
  thin: "sans-serif-thin",
};

================
File: src/app/types/env.d.ts
================
declare module "@env" {
  export const API_URL: string;
  export const API_KEY: string;
  export const ENVIRONMENT: "development" | "staging" | "production";
  export const VERSION: string;
  export const BUILD_NUMBER: string;
}

================
File: src/app/types/theme.types.ts
================
// Define los tipos para el sistema de temas de la aplicación
import { z } from "zod";
import { MD3Theme } from "react-native-paper";

// Definición de las posibles preferencias de tema
export const themePreferenceSchema = z.enum(["light", "dark", "system"]);
export type ThemePreference = z.infer<typeof themePreferenceSchema>;

// Clave para almacenar la preferencia de tema en AsyncStorage
export const THEME_PREFERENCE_STORAGE_KEY = "app:theme_preference";

// Valores constantes para facilitar el uso en el código
export const THEME_MODE = {
  LIGHT: "light",
  DARK: "dark",
  SYSTEM: "system",
} as const;

// Extender el tema de Paper si es necesario
export interface AppTheme extends MD3Theme {
  // Aquí puedes agregar propiedades adicionales al tema si es necesario
}

// Tipo para el estado del tema en el store
export interface ThemeState {
  preference: ThemePreference;
  setPreference: (preference: ThemePreference) => void;
}

================
File: src/modules/auth/components/LoginForm.tsx
================
import React, { useState } from "react";
import { View, StyleSheet } from "react-native";
import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { TextInput, Button, HelperText } from "react-native-paper";
import { useAppTheme } from "../../../app/styles/theme";

// Esquema de validación con Zod
const loginSchema = z.object({
  // Permitir email o username, refinar luego si es necesario validar formato específico
  emailOrUsername: z
    .string()
    .min(1, "El correo o nombre de usuario es requerido"),
  password: z.string().min(6, "La contraseña debe tener al menos 6 caracteres"),
});

// Inferir el tipo de los inputs desde el esquema Zod
type LoginFormInputs = z.infer<typeof loginSchema>;

interface LoginFormProps {
  onSubmit: (data: LoginFormInputs) => void;
  isLoading: boolean;
}

const LoginForm: React.FC<LoginFormProps> = ({ onSubmit, isLoading }) => {
  const theme = useAppTheme();
  const [secureTextEntry, setSecureTextEntry] = useState(true);

  const {
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormInputs>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      emailOrUsername: "",
      password: "",
    },
  });

  const toggleSecureEntry = () => {
    setSecureTextEntry(!secureTextEntry);
  };

  // Estilos que dependen del tema
  const styles = StyleSheet.create({
    container: {
      width: "100%",
    },
    input: {
      marginBottom: 8,
      // backgroundColor: theme.colors.surface, // TextInput de Paper maneja su fondo basado en el modo y tema
    },
    button: {
      marginTop: 16,
    },
    helperText: {
      // El color del HelperText tipo 'error' se maneja por el tema
      marginBottom: 8,
    },
  });

  return (
    <View style={styles.container}>
      <Controller
        control={control}
        name="emailOrUsername"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Correo o Usuario"
              mode="outlined" // O 'flat' según preferencia de diseño
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              error={!!errors.emailOrUsername}
              style={styles.input}
              autoCapitalize="none"
              keyboardType="email-address" // Asume email como más común, pero permite username
              disabled={isLoading}
            />
            {/* Corrección: Usar && para renderizado condicional */}
            {errors.emailOrUsername && (
              <HelperText
                type="error"
                visible={!!errors.emailOrUsername}
                style={styles.helperText}
              >
                {errors.emailOrUsername?.message}
              </HelperText>
            )}
          </View>
        )}
      />

      <Controller
        control={control}
        name="password"
        render={({ field: { onChange, onBlur, value } }) => (
          <View>
            <TextInput
              label="Contraseña"
              mode="outlined"
              onBlur={onBlur}
              onChangeText={onChange}
              value={value}
              secureTextEntry={secureTextEntry}
              error={!!errors.password}
              style={styles.input}
              right={
                <TextInput.Icon
                  icon={secureTextEntry ? "eye" : "eye-off"}
                  onPress={toggleSecureEntry}
                  forceTextInputFocus={false} // Evita que el input gane foco al tocar el icono
                  color={errors.password ? theme.colors.error : undefined} // Cambia color del icono si hay error
                />
              }
              disabled={isLoading}
            />
            {/* Corrección: Usar && para renderizado condicional */}
            {errors.password && (
              <HelperText
                type="error"
                visible={!!errors.password}
                style={styles.helperText}
              >
                {errors.password?.message}
              </HelperText>
            )}
          </View>
        )}
      />

      <Button
        mode="contained"
        onPress={handleSubmit(onSubmit)}
        loading={isLoading}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? "Ingresando..." : "Ingresar"}
      </Button>
    </View>
  );
};

export default LoginForm;

================
File: src/modules/auth/screens/LoginScreen.tsx
================
import React from "react";
import {
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  StyleSheet,
  View,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { Text, IconButton, Surface, TouchableRipple } from "react-native-paper";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useNavigation } from "@react-navigation/native";
import { useAppTheme } from "../../../app/styles/theme";
import { useSnackbarStore } from "../../../app/store/snackbarStore";
import { useThemeStore } from "../../../app/store/themeStore";
import { useAuthStore } from "../../../app/store/authStore";
import { LoginFormInputs, LoginResponseDto } from "../types/auth.types";
import { authService } from "../services/authService";
import LoginForm from "../components/LoginForm";

const LoginScreen = () => {
  const theme = useAppTheme();
  const queryClient = useQueryClient();
  const navigation = useNavigation();
  const { showSnackbar } = useSnackbarStore();
  const { themePreference, setThemePreference } = useThemeStore();
  const setToken = useAuthStore((state) => state.setToken);

  // Mutación de login
  const loginMutation = useMutation<LoginResponseDto, Error, LoginFormInputs>({
    mutationFn: (loginData) => authService.login(loginData),
    onSuccess: async (data) => {
      try {
        await setToken(data.token);
        showSnackbar({
          message: `¡Bienvenido!`,
          type: "success",
        });
        queryClient.invalidateQueries({ queryKey: ["user", "me"] });
        // TODO: Implementar navegación a la pantalla principal
        console.log("Navegación pendiente a la pantalla principal");
      } catch (error) {
        console.error("Error al guardar token:", error);
        showSnackbar({
          message: "Error procesando el inicio de sesión.",
          type: "error",
        });
      }
    },
    onError: (error) => {
      showSnackbar({
        message:
          error.message ||
          "Error al iniciar sesión. Por favor, intenta de nuevo.",
        type: "error",
        duration: 5000,
      });
    },
  });

  const handleLoginSubmit = (data: LoginFormInputs) => {
    loginMutation.mutate(data);
  };

  const toggleTheme = () => {
    setThemePreference(theme.dark ? "light" : "dark");
  };

  // Estilos memoizados que dependen del tema
  const styles = React.useMemo(
    () =>
      StyleSheet.create({
        safeArea: {
          flex: 1,
          backgroundColor: theme.colors.background,
        },
        scrollView: {
          flexGrow: 1,
        },
        container: {
          flex: 1,
          padding: 24,
          justifyContent: "space-between",
        },
        logoContainer: {
          alignItems: "center",
          marginTop: 30,
          marginBottom: 5,
        },
        logo: {
          width: 120,
          height: 120,
          marginBottom: 16,
        },
        title: {
          fontSize: 32,
          fontWeight: "bold",
          color: theme.colors.primary,
          marginBottom: 8,
          textAlign: "center",
        },
        subtitle: {
          fontSize: 16,
          color: theme.colors.onSurfaceVariant,
          marginBottom: 20,
          textAlign: "center",
          paddingHorizontal: 20,
        },
        formContainer: {
          backgroundColor: theme.colors.surface,
          borderRadius: 16,
          padding: 24,
          elevation: 2,
          marginBottom: 16,
        },
        forgotPassword: {
          color: theme.colors.primary,
          textAlign: "right",
          marginTop: 8,
          marginBottom: 16,
        },
        registerContainer: {
          flexDirection: "row",
          justifyContent: "center",
          alignItems: "center",
          marginTop: 20,
        },
        registerText: {
          color: theme.colors.onSurfaceVariant,
          marginRight: 8,
        },
        registerLink: {
          color: theme.colors.primary,
          fontWeight: "bold",
        },
        bottomThemeToggleContainer: {
          alignItems: "center",
          marginTop: 20,
          marginBottom: 16,
        },
      }),
    [theme]
  );

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={{ flex: 1 }}
      >
        <ScrollView
          contentContainerStyle={styles.scrollView}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.container}>
            {/* Sección Superior (Logo, Títulos) */}
            <View>
              <View style={styles.logoContainer}>
                <Image
                  source={require("../../../assets/logo.png")}
                  style={styles.logo}
                  resizeMode="contain"
                />
                <Text style={styles.title}>¡Bienvenido!</Text>
                <Text style={styles.subtitle}>
                  Inicia sesión para gestionar tus pedidos
                </Text>
              </View>

              <Surface style={styles.formContainer}>
                <LoginForm
                  onSubmit={handleLoginSubmit}
                  isLoading={loginMutation.isPending}
                />
              </Surface>

              <TouchableRipple
                onPress={() => console.log("Olvidé mi contraseña")}
              >
                <Text style={styles.forgotPassword}>
                  ¿Olvidaste tu contraseña?
                </Text>
              </TouchableRipple>
            </View>

            {/* Sección Inferior (Registro, Cambio de Tema) */}
            <View>
              <View style={styles.registerContainer}>
                <Text style={styles.registerText}>¿No tienes una cuenta?</Text>
                <TouchableRipple
                  onPress={() => console.log("Navegar a registro")}
                >
                  <Text style={styles.registerLink}>Regístrate</Text>
                </TouchableRipple>
              </View>
              <View style={styles.bottomThemeToggleContainer}>
                <IconButton
                  icon={theme.dark ? "weather-night" : "weather-sunny"}
                  size={28}
                  onPress={toggleTheme}
                  iconColor={theme.colors.onSurfaceVariant}
                />
              </View>
            </View>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

export default LoginScreen;

================
File: src/modules/auth/services/authService.ts
================
import apiClient from "../../../app/services/apiClient";
import {
  AuthEmailLoginDto,
  LoginResponseDto,
  LoginFormInputs,
} from "../types/auth.types";

class AuthService {
  async login(loginData: LoginFormInputs): Promise<LoginResponseDto> {
    // Determinar si es email o username
    const isEmail = loginData.emailOrUsername.includes("@");
    const payload: AuthEmailLoginDto = {
      password: loginData.password,
      ...(isEmail
        ? { email: loginData.emailOrUsername }
        : { username: loginData.emailOrUsername }),
    };

    // Realizar la petición POST al endpoint de login
    const response = await apiClient.post<LoginResponseDto>(
      "/api/v1/auth/email/login",
      payload
    );

    // Apisauce envuelve la respuesta. Verificamos si fue exitosa.
    if (!response.ok || !response.data) {
      // Intentar obtener un mensaje de error más específico si está disponible
      const apiError =
        (response.data as any)?.errors?.auth ||
        (response.data as any)?.errors?.password ||
        "credentialsIncorrect";
      // Mapear errores del backend a mensajes amigables
      const errorMessages: { [key: string]: string } = {
        credentialsIncorrect: "Usuario o contraseña incorrectos.",
        incorrectPassword: "La contraseña es incorrecta.",
      };
      throw new Error(errorMessages[apiError] || "Error al iniciar sesión.");
    }
    return response.data;
  }

  // Aquí podrían ir otros métodos relacionados con la autenticación
  // como logout, refreshToken, resetPassword, etc.
}

export const authService = new AuthService();

================
File: src/modules/auth/types/auth.types.ts
================
import { z } from "zod";

// Esquema de validación para el formulario de login
export const loginSchema = z.object({
  emailOrUsername: z
    .string()
    .min(1, "El correo o nombre de usuario es requerido"),
  password: z.string().min(6, "La contraseña debe tener al menos 6 caracteres"),
});

// Tipo inferido del esquema de login
export type LoginFormInputs = z.infer<typeof loginSchema>;

// Esquema para la respuesta de autenticación
export const authResponseSchema = z.object({
  token: z.string(),
  user: z.object({
    id: z.string(),
    email: z.string().email(),
    username: z.string(),
    role: z.enum(["admin", "staff"]),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().url().optional(),
  }),
});

// Tipo inferido del esquema de respuesta de autenticación
export type AuthResponse = z.infer<typeof authResponseSchema>;

// Tipo para el estado de autenticación en el store
export interface AuthState {
  token: string | null;
  user: AuthResponse["user"] | null;
  isLoading: boolean;
  error: string | null;
  login: (credentials: LoginFormInputs) => Promise<void>;
  logout: () => void;
  clearError: () => void;
}

// DTO para la petición de login al backend
// Basado en AuthEmailLoginDto del backend, permitiendo email o username
export const authEmailLoginDtoSchema = z.object({
  email: z.string().email().optional(),
  username: z.string().optional(),
  password: z.string(),
});
export type AuthEmailLoginDto = z.infer<typeof authEmailLoginDtoSchema>;

// Simplificación del tipo User basado en el backend para la respuesta
// Ajustar según los campos realmente necesarios en el frontend
const userSchema = z.object({
  id: z.string().uuid(), // Asumiendo UUID como string
  email: z.string().email().nullable(),
  username: z.string().nullable(),
  firstName: z.string().nullable(),
  lastName: z.string().nullable(),
  // Añadir otros campos relevantes si son necesarios (role, status, etc.)
  role: z.object({ id: z.number() }).optional(), // Asumiendo ID numérico para rol
});
export type User = z.infer<typeof userSchema>;

// DTO para la respuesta del login del backend
export const loginResponseDtoSchema = z.object({
  token: z.string(),
  refreshToken: z.string(),
  tokenExpires: z.number(), // O z.string() si la API devuelve una fecha/string
  user: userSchema,
});
export type LoginResponseDto = z.infer<typeof loginResponseDtoSchema>;

// Podrías añadir aquí otros DTOs y tipos relacionados con auth (register, forgot password, etc.)

================
File: .cursor/rules/expo.mdc
================
---
description: 
globs: 
alwaysApply: true
---
---
description: Guía específica de Estilo, Arquitectura y Convenciones para ClearByte (Android). Basada en Expo SDK 52, React Native 0.76, TypeScript, React Native Paper 5 (MD3), Zustand 5, React Query 5, Apisauce 3. Estructura app/modules.
globs:
  - "src/**/*.ts"
  - "src/**/*.tsx"
alwaysApply: true
---

# Guía de Estilo, Arquitectura y Convenciones del Proyecto (ClearByte) (ANDROID)

Este documento es la **fuente de verdad** para las convenciones de codificación, arquitectura y uso de librerías en ClearByte. Utiliza Expo (SDK 52), React Native (0.76), TypeScript, y un stack moderno incluyendo React Native Paper (v5), Zustand (v5), React Query (v5), y Apisauce (v3). **La aplicación soporta temas claro y oscuro**. La estructura del proyecto se basa en una separación clara entre código central/compartido (`src/app`) y módulos de funcionalidades específicas (`src/modules`).

**Objetivo:** Código limpio, mantenible, performante, y una excelente UX adaptable.

---

## 1. Estilo y Estructura del Código

*   **Concisión y Claridad:** Código `TypeScript` técnico y bien documentado donde sea necesario (JSDoc para funciones complejas o utilidades).
*   **Programación Funcional:** Funciones y hooks sobre clases. Patrones declarativos.
*   **Modularidad (DRY):** Crear componentes y hooks reutilizables. Colocar en `app/` si son globales, o dentro del módulo si son específicos.
*   **Nombres Descriptivos:** Variables y funciones con nombres claros (ej., `isLoading`, `isError`, `data`, `loginMutation`, `toggleTheme`, `handleLoginSubmit`).
*   **Estructura de Archivos (Organización por Módulos - Actual):**
    *   `src/`
        *   `app/`: Código central, compartido y transversal.
            *   `components/`: Componentes UI globales reutilizables.
                *   `common/`: Componentes muy genéricos (`GlobalSnackbar.tsx`).
                *   *(otros...)*: (ej., `StyledButton.tsx` si se crea)
            *   `constants/`: (A crear) Valores fijos globales (claves Storage, URLs base si no van en env).
            *   `hooks/`: (A crear) Hooks personalizados globales (ej., `useNetworkStatus`).
            *   `lib/`: (A crear) Utilidades generales globales (ej., helpers `date-fns`).
            *   `navigation/`: (A crear) Configuración de `react-navigation` raíz (Drawer, Stacks principales), tipos globales de navegación.
            *   `services/`: Configuración centralizada (`apiClient.ts`).
            *   `store/`: Stores globales de Zustand (`authStore.ts`, `themeStore.ts`, `snackbarStore.ts`).
            *   `styles/`: **TODA** la configuración de tema (`colors.ts`, `typography.ts`, `theme.ts` que exporta `useAppTheme`).
            *   `types/`: Definiciones TS globales (`env.d.ts`, `theme.types.ts`).
        *   `modules/`: Funcionalidades/dominios principales.
            *   `auth/`: Módulo de Autenticación (Existente).
                *   `components/`: `LoginForm.tsx`.
                *   `screens/`: `LoginScreen.tsx`.
                *   `services/`: `authService.ts` (usa `app/services/apiClient`).
                *   `types/`: `auth.types.ts` (contiene DTOs, Zod schemas, tipos de formulario/estado específicos de auth).
            *   *(otros módulos...)*: (ej., `orders/`, `menu/`, `settings/` a crear siguiendo la misma estructura interna según necesidad).
        *   `assets/`: (A crear) Recursos estáticos (fuentes `.ttf`/`.otf`, imágenes `.png`/`.jpg`, Lottie `.json`). **Nota:** El logo actualmente se importa con `require('../../../assets/logo.png')` en `LoginScreen`, asegúrate de que la carpeta `assets` esté en la raíz de `src/` o ajusta la ruta.

---

## 2. Convenciones de Nomenclatura

*   **Directorios:** `kebab-case` (ej., `app/components/common`, `modules/auth`).
*   **Archivos (Componentes):** `PascalCase` (ej., `LoginForm.tsx`, `GlobalSnackbar.tsx`).
*   **Archivos (Otros):** `camelCase` (ej., `apiClient.ts`, `authStore.ts`, `theme.ts`). **Convención:** Usar `*.types.ts` para archivos de tipos dentro de los módulos (ej., `auth.types.ts`).
*   **Exportaciones:** Preferir `named exports`. Usar `export default` para componentes de pantalla (`screens`).

---

## 3. Uso de TypeScript

*   **Obligatorio:** `strict: true` en `tsconfig.json`.
*   **Interfaces vs Tipos:** `interface` para formas de objetos/props; `type` para uniones (`|`), intersecciones (`&`), alias, funciones.
*   **Evitar Enums:** Usar `as const` o `type` unions.
*   **Componentes Funcionales:** Tipar props (`interface Props`), retorno `JSX.Element` o `React.FC<Props>`.
*   **Validación con `zod` (v3):**
    *   **Uso:** Estándar para validar datos (formularios, DTOs API).
    *   **Definición:** Esquemas (`z.object`, `z.string`, etc.) en `*.types.ts` dentro del módulo correspondiente (ej., `modules/auth/types/auth.types.ts`).
    *   **Validación Formularios:** Usar con `react-hook-form` (v7) vía `@hookform/resolvers` (v5): `resolver: zodResolver(mySchema)`.
    *   **Inferencia:** **SIEMPRE** usar `z.infer<typeof mySchema>` para derivar tipos TS.
    ```typescript
    // src/modules/auth/types/auth.types.ts
    import { z } from 'zod';
    // Esquema para el form
    export const loginSchema = z.object({ emailOrUsername: z.string().min(1), /*...*/ });
    export type LoginFormInputs = z.infer<typeof loginSchema>;
    // Esquema para la respuesta API (DTO)
    export const loginResponseDtoSchema = z.object({ token: z.string(), /*...*/ });
    export type LoginResponseDto = z.infer<typeof loginResponseDtoSchema>;
    ```

---

## 4. Sintaxis y Formato

*   **`function` vs Arrow:** `function` para componentes/utilidades puras; `=>` para callbacks (`onPress`, `useEffect`), funciones internas.
*   **Concisión:** `&&` para renderizado condicional; evitar `{}` innecesarios.
*   **JSX Declarativo:** Extraer lógica compleja.
*   **ESLint + Prettier:** Configurados (`.eslintrc.js`, `.prettierrc.js`). Asegurar integración con editor y pre-commit hooks. Sigue las reglas definidas.

---

## 5. UI y Estilos

*   **Librería UI: `react-native-paper` (v5 - MD3)**
    *   Componentes base (`Button`, `TextInput`, `Surface`, `Text`, `IconButton`, etc.).
    *   **Theming:** Configuración centralizada en `src/app/styles/`.
        *   `colors.ts`: Paletas `lightColors`, `darkColors` (incluye `success`, `warning`, `info` y sus `Container`/`onContainer`).
        *   `typography.ts`: Define `typography` (usando `Platform.select` para fuentes base).
        *   `theme.ts`: Crea `lightTheme`, `darkTheme`. Extiende `MD3LightTheme`/`MD3DarkTheme` con colores y fuentes personalizadas. Define `spacing`, `roundness`. **Exporta `useAppTheme = () => useTheme<AppTheme>()` para acceso tipado.**
*   **Iconos: `@expo/vector-icons` (v14)**
    *   Usar nombres de icono directamente en props de Paper (ej., `icon="eye"`).
*   **Layout:** `Flexbox` vía `StyleSheet` de React Native.
*   **Modo Claro/Oscuro:**
    *   **Gestión:** `src/app/store/themeStore.ts` (Zustand). Guarda `themePreference` en `AsyncStorage`. Determina `activeTheme`.
    *   **Detección Sistema:** `useSystemThemeDetector` (en `themeStore.ts`) usa `useColorScheme`. Llamar una vez en `App.tsx`.
    *   **Aplicación en Componentes:**
        *   Obtener tema: `const theme = useAppTheme();` (importado de `src/app/styles/theme`).
        *   Estilos: **SIEMPRE** usar `theme.colors.*`, `theme.fonts.*`, `theme.spacing.*`, `theme.roundness` en `StyleSheet.create`.
        *   Memoización: Si los estilos dependen del tema dentro de un componente, usar `React.useMemo`: `const styles = React.useMemo(() => StyleSheet.create({...}), [theme]);`.
        *   **PROHIBIDO Hardcodear Colores:** No usar `'#FFF'`, `'black'`, etc.
    *   **Proveedor Raíz:** `PaperProvider` en `App.tsx` con `theme={activeTheme}`.
*   **Accesibilidad (a11y):** Props `accessibility*`. Buen contraste en `colors.ts`. Testear.
*   **Animaciones:**
    *   Navegación/Gestos: `react-native-reanimated` (v3), `react-native-gesture-handler` (v2) (Dependencias de Navigation).
    *   Indicadores/UX: `lottie-react-native` (v7) para animaciones Lottie.

---

## 6. Gestión del Área Segura (Safe Area)

*   **Proveedor:** `SafeAreaProvider` de `react-native-safe-area-context` (v4) en la raíz.
*   **Uso:** `SafeAreaView` de `react-native-safe-area-context` como contenedor principal en pantallas (`src/modules/*/screens/*`).

---

## 7. Optimización del Rendimiento

*   **Estado Servidor: `@tanstack/react-query` (v5)**
    *   **Obligatorio:** Para toda data fetching/mutation.
    *   **Uso:** `useQuery` (fetch), `useMutation` (CUD). `queryKey` descriptivos. `queryClient.invalidateQueries` en `onSuccess` de mutaciones. `QueryClientProvider` en raíz.
*   **Estado Global Cliente: `zustand` (v5)**
    *   **Uso:** Estado global no-servidor.
    *   **Stores:** En `src/app/store/` (`authStore`, `themeStore`, `snackbarStore`).
    *   **Persistencia:** `persist` middleware (`zustand/middleware`) con `createJSONStorage(() => AsyncStorage)` o `EncryptedStorage`. Usado en `themeStore` con `AsyncStorage`.
*   **Imágenes: `expo-image` (v2)**
    *   Usar sobre `react-native` `<Image>`. Proporcionar `width`, `height`. Beneficios de caching/formato (WebP).
*   **Renderizados:** `React.memo`, `useMemo` (para estilos/cálculos), `useCallback` con moderación.
*   **Listas:** `FlatList`/`SectionList`. `keyExtractor`. `extraData={theme}` si es necesario.
*   **Inicio App:** `expo-splash-screen` (no listado pero recomendado).

---

## 8. Navegación

*   **Librería: `react-navigation` (v7)**
    *   Dependencias: `@react-navigation/native`, `@react-navigation/native-stack` (v7), `@react-navigation/drawer` (v7) (u otros navegadores).
    *   **Configuración:** Principal en `src/app/navigation/`.
    *   **Theming:** Aplicar colores/fuentes de `useAppTheme` en `screenOptions`.
*   **Dependencias Clave:** `react-native-screens` (v4), `react-native-gesture-handler` (v2), `react-native-safe-area-context` (v4).
*   **Tipado:** Rutas y parámetros en `src/app/navigation/types.ts` (globales) o `src/modules/*/navigation/types.ts` (específicos).
*   **URL Polyfill:** `react-native-url-polyfill` (v2) está instalado, puede ser necesario para algunas librerías o APIs web.

---

## 9. Comunicación con API

*   **Cliente HTTP: `apisauce` (v3)**
    *   **Configuración Central:** `src/app/services/apiClient.ts`.
        *   `baseURL` desde `@env` (`API_URL`).
        *   Interceptor (`addAsyncRequestTransform`) para añadir `Authorization: Bearer <token>` (token leído desde `EncryptedStorage`).
        *   Monitor (`addMonitor`) para 401 (llama a `authStore.logout`) y logueo de otros errores (`!response.ok`).
    *   **Servicios Específicos:** En `src/modules/*/services/` (ej., `authService.ts`). Importan y usan `apiClient` central. Lanzan errores (`throw new Error(...)`) en caso de fallo para React Query.
*   **Variables de Entorno:** Usar `react-native-dotenv`. Definir tipos en `src/app/types/env.d.ts`. Acceder con `import { VAR_NAME } from '@env';`. **Variables actuales:** `API_URL`, `API_KEY`, `ENVIRONMENT`, `VERSION`, `BUILD_NUMBER`.

---

## 10. Manejo de Formularios

*   **Librería: `react-hook-form` (v7)**
    *   Usar `useForm`, `Controller`.
*   **Validación:** `zod` (v3) + `@hookform/resolvers` (v5) `zodResolver`. Esquemas en `src/modules/*/types/*.types.ts`.
*   **UI:** Inputs de `react-native-paper`. `HelperText type="error"` para mostrar errores de `formState.errors`.

---

## 11. Manejo de Errores

*   **Validación:** `zod` en formularios.
*   **API:** React Query (`isError`, `error`, `onError` en `useMutation`). `GlobalSnackbar` (vía `snackbarStore`) para feedback. Monitor 401 en `apiClient`.
*   **Runtime:** `ErrorBoundary`.
*   **Conectividad: `@react-native-community/netinfo` (v11)**. Hook/store en `src/app/`.
*   **Logging:** Sentry (recomendado).

---

## 12. Funcionalidades Nativas y Hardware

*   **Almacenamiento:**
    *   **Preferencias No Sensibles:** `@react-native-async-storage/async-storage` (v2) (usado por `themeStore`).
    *   **Datos Sensibles (Tokens):** `react-native-encrypted-storage` (v4) (usado por `authStore`). **Requiere `expo-dev-client`**.
*   **Librerías Expo/Comunidad Instaladas:**
    *   `@expo/vector-icons`: Iconos.
    *   `@react-native-community/datetimepicker`: Selector Fecha/Hora nativo. **Requiere `expo-dev-client`**.
    *   `@react-native-community/netinfo`: Estado de red. **Requiere `expo-dev-client`**.
    *   `expo-audio`: Reproducción de audio.
    *   `expo-file-system`: Acceso a archivos.
    *   `expo-image`: Componente de imagen optimizado.
    *   `expo-image-picker`: Selección/toma de imágenes.
    *   `expo-notifications`: Notificaciones Push/Locales.
    *   `expo-print`: Generación PDF / Impresión estándar OS.
    *   `expo-status-bar`: Control barra de estado.
*   **Permisos:** Solicitar just-in-time usando las APIs de los módulos Expo.

---

## 13. Build y Desarrollo

*   **Development Builds:** **`expo-dev-client` (v5) es OBLIGATORIO** debido a las dependencias nativas (`encrypted-storage`, `netinfo`, `datetimepicker`). Workflow: `eas build -p development` / `npx expo run:*`, luego `npx expo start --dev-client`.
*   **EAS Build:** Usar para todos los tipos de build. Gestionar secretos/variables de entorno con **EAS Secrets**.
*   **Expo Updates:** Configurar `expo-updates` para actualizaciones OTA.

---

## 14. Utilidades Adicionales

*   **Fechas/Horas: `date-fns` (v4)**
    *   Uso estándar. Helpers en `src/app/lib/`.

---

## 15. Seguridad

*   **HTTPS:** Asegurado en `apiClient` (`API_URL` debe ser HTTPS).
*   **Tokens:** Almacenamiento seguro (`EncryptedStorage`), transmisión segura (Interceptor).
*   **Validación:** `zod`.
*   **Secretos:** Usar **EAS Secrets** + `@env`. **NO hardcodear `API_KEY` u otros secretos.**
*   **Dependencias:** Mantener actualizadas (`npm outdated`, `npm audit`).

---

## 16. Estructura para Nuevos Features/Módulos

1.  **Crear Carpeta:** `src/modules/newFeatureName/`.
2.  **Añadir Subcarpetas:** `components/`, `screens/`, `services/`, `types/`, etc., según necesidad.
3.  **Integrar:** Añadir pantallas a `src/app/navigation/`, usar elementos de `src/app/`, importar elementos internos del módulo.



================================================================
End of Codebase
================================================================
